#+TITLE: Dan's DOOM emacs config


* TODO Rationale

** TODO My vainilla emacs adventures

** TODO Why Doom?

[[https://blog.jethro.dev/posts/migrating_to_doom_emacs/][It's easy once you know what you are doing.]]

* Installation

** TODO Prerequesites

* Configuration

Blocks preceded with =IE= are just examples that are not evaluated, the rest of the blocks are put in the filename of the corresponding heading.

** init.el

This file controls what Doom modules are enabled and what order they load
in. Remember to run 'doom sync' after modifying it!

*** Lexical binding.

Elisp by default has dynamic-scope, which is fine if a little weird. However,
dynamic scope comes with a performence penalty. Optional lexical scope has to be
activated with a file parameter, as such:

#+begin_src elisp :tangle init.el
;;; init.el -*- lexical-binding: t; -*-
#+end_src


*** doom!

The ~doom!~ macro controls which modules are loaded into doom emacs. Modules are
package configurations made by the community. In the spirit of emacs, all the
configuration that comes with a particular module can be extended or even completly
overwritten by your private config.

Modules are completly open for discovery.Press 'SPC h d h' (or 'C-h d h' for
non-vim users) to access Doom's documentation. There you'll find a "Module
Index" link where you'll find a comprehensive list of Doom's modules and what
flags they support.

Alternatively, press 'gd' (or 'C-c c d') on a module to browse its directory
(for easy access to its source code).

#+begin_src elisp :tangle init.el
(doom! :input
       ;;chinese
       ;;japanese
       ;;layout            ; auie,ctsrnm is the superior home row

       :completion
       company           ; the ultimate code completion backend
       ;;helm              ; the *other* search engine for love and life
       ;;ido               ; the other *other* search engine...
       (ivy +icons)        ; a search engine for love and life

       :ui
       ;;deft              ; notational velocity for Emacs
       doom              ; what makes DOOM look the way it does
       doom-dashboard    ; a nifty splash screen for Emacs
       doom-quit         ; DOOM quit-message prompts when you quit Emacs
       ;;fill-column       ; a `fill-column' indicator
       hl-todo           ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
       ;;hydra
       ;;indent-guides     ; highlighted indent columns
       ;;ligatures         ; ligatures and symbols to make your code pretty again
       ;;minimap           ; show a map of the code on the side
       modeline          ; snazzy, Atom-inspired modeline, plus API
       ;;nav-flash         ; blink cursor line after big motions
       ;;neotree           ; a project drawer, like NERDTree for vim
       ophints           ; highlight the region an operation acts on
       (popup +defaults)   ; tame sudden yet inevitable temporary windows
       ;;tabs              ; a tab bar for Emacs
       ;;treemacs          ; a project drawer, like neotree but cooler
       ;;unicode           ; extended unicode support for various languages
       vc-gutter         ; vcs diff in the fringe
       vi-tilde-fringe   ; fringe tildes to mark beyond EOB
       ;;window-select     ; visually switch windows
       workspaces        ; tab emulation, persistence & separate workspaces
       ;;zen               ; distraction-free coding or writing

       :editor
       (evil +everywhere); come to the dark side, we have cookies
       file-templates    ; auto-snippets for empty files
       fold              ; (nigh) universal code folding
       ;;(format +onsave)  ; automated prettiness
       ;;god               ; run Emacs commands without modifier keys
       ;;lispy             ; vim for lisp, for people who don't like vim
       ;;multiple-cursors  ; editing in many places at once
       ;;objed             ; text object editing for the innocent
       ;;parinfer          ; turn lisp into python, sort of
       ;;rotate-text       ; cycle region at point between text candidates
       snippets          ; my elves. They type so I don't have to
       ;;word-wrap         ; soft wrapping with language-aware indent

       :emacs
       dired             ; making dired pretty [functional]
       electric          ; smarter, keyword-based electric-indent
       ;;ibuffer         ; interactive buffer management
       undo              ; persistent, smarter undo for your inevitable mistakes
       vc                ; version-control and Emacs, sitting in a tree

       :term
       ;;eshell            ; the elisp shell that works everywhere
       ;;shell             ; simple shell REPL for Emacs
       ;;term              ; basic terminal emulator for Emacs
       vterm             ; the best terminal emulation in Emacs

       :checkers
       syntax              ; tasing you for every semicolon you forget
       ;;spell             ; tasing you for misspelling mispelling
       ;;grammar           ; tasing grammar mistake every you make

       :tools
       ;;ansible
       ;;debugger          ; FIXME stepping through code, to help you add bugs
       ;;direnv
       ;;docker
       ;;editorconfig      ; let someone else argue about tabs vs spaces
       ;;ein               ; tame Jupyter notebooks with emacs
       (eval +overlay)     ; run code, run (also, repls)
       ;;gist              ; interacting with github gists
       lookup              ; navigate your code and its documentation
       lsp
       magit             ; a git porcelain for Emacs
       ;;make              ; run make tasks from Emacs
       ;;pass              ; password manager for nerds
       pdf               ; pdf enhancements
       ;;prodigy           ; FIXME managing external services & code builders
       ;;rgb               ; creating color strings
       ;;taskrunner        ; taskrunner for all your projects
       ;;terraform         ; infrastructure as code
       ;;tmux              ; an API for interacting with tmux
       ;;upload            ; map local to remote projects via ssh/ftp

       :os
       (:if IS-MAC macos)  ; improve compatibility with macOS
       ;;tty               ; improve the terminal Emacs experience

       :lang
       ;;agda              ; types of types of types of types...
       ;;cc                ; C/C++/Obj-C madness
       ;;clojure           ; java with a lisp
       ;;common-lisp       ; if you've seen one lisp, you've seen them all
       ;;coq               ; proofs-as-programs
       ;;crystal           ; ruby at the speed of c
       ;;csharp            ; unity, .NET, and mono shenanigans
       ;;data              ; config/data formats
       ;;(dart +flutter)   ; paint ui and not much else
       ;;elixir            ; erlang done right
       ;;elm               ; care for a cup of TEA?
       emacs-lisp        ; drown in parentheses
       ;;erlang            ; an elegant language for a more civilized age
       ;;ess               ; emacs speaks statistics
       ;;faust             ; dsp, but you get to keep your soul
       ;;fsharp            ; ML stands for Microsoft's Language
       ;;fstar             ; (dependent) types and (monadic) effects and Z3
       ;;gdscript          ; the language you waited for
       ;;(go +lsp)         ; the hipster dialect
       ;;(haskell +dante)  ; a language that's lazier than I am
       ;;hy                ; readability of scheme w/ speed of python
       ;;idris             ;
       ;;json              ; At least it ain't XML
       ;;(java +meghanada) ; the poster child for carpal tunnel syndrome
       ;;javascript        ; all(hope(abandon(ye(who(enter(here))))))
       ;;julia             ; a better, faster MATLAB
       ;;kotlin            ; a better, slicker Java(Script)
       ;;latex             ; writing papers in Emacs has never been so fun
       ;;lean
       ;;factor
       ;;ledger            ; an accounting system in Emacs
       ;;lua               ; one-based indices? one-based indices
       markdown          ; writing docs for people to ignore
       ;;nim               ; python + lisp at the speed of c
       ;;nix               ; I hereby declare "nix geht mehr!"
       ;;ocaml             ; an objective camel
       org               ; organize your plain life in plain text
       ;;php               ; perl's insecure younger brother
       ;;plantuml          ; diagrams for confusing people more
       ;;purescript        ; javascript, but functional
       ;;python            ; beautiful is better than ugly
       ;;qt                ; the 'cutest' gui framework ever
       ;;racket            ; a DSL for DSLs
       ;;raku              ; the artist formerly known as perl6
       ;;rest              ; Emacs as a REST client
       ;;rst               ; ReST in peace
       ;;(ruby +rails)     ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
       (rust +lsp)              ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
       ;;scala             ; java, but good
       ;;scheme            ; a fully conniving family of lisps
       sh                ; she sells {ba,z,fi}sh shells on the C xor
       ;;sml
       ;;solidity          ; do you need a blockchain? No.
       ;;swift             ; who asked for emoji variables?
       ;;terra             ; Earth and Moon in alignment for performance.
       ;;web               ; the tubes
       ;;yaml              ; JSON, but readable

       :email
       ;;(mu4e +gmail)
       ;;notmuch
       ;;(wanderlust +gmail)

       :app
       ;;calendar
       ;;irc               ; how neckbeards socialize
       (rss +org)        ; emacs as an RSS reader
       ;;twitter           ; twitter client https://twitter.com/vnought

       :config
       literate
       (default +bindings +smartparens))
#+end_src

** package.el

*** Lexical binding

#+begin_src elisp :tangle packages.el
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el
#+end_src

*** How does package.el work?

To install a package with Doom you must declare them here and run ~doom sync~
on the command line, then restart Emacs for the changes to take effect -- or
use ~M-x doom/reload~.

To install SOME-PACKAGE from MELPA, ELPA or emacsmirror:

IE:
#+begin_src elisp :tangle no
(package! some-package)
#+end_src

To install a package directly from a remote git repo, you must specify a
~:recipe~. You'll find documentation on what ~:recipe~ accepts here:
https://github.com/raxod502/straight.el#the-recipe-format

IE:
#+begin_src elisp :tangle no
(package! another-package
  :recipe (:host github :repo "username/repo"))
#+end_src

If the package you are trying to install does not contain a PACKAGENAME.el
file, or is located in a subdirectory of the repo, you'll need to specify
~:files~ in the ~:recipe~:

IE:
#+begin_src elisp :tangle no
(package! this-package
  :recipe (:host github :repo "username/repo"
           :files ("some-file.el" "src/lisp/*.el")))   
#+end_src

If you'd like to disable a package included with Doom, you can do so here
with the ~:disable~ property:

IE:
#+begin_src elisp :tangle no
(package! builtin-package :disable t)
#+end_src

You can override the recipe of a built in package without having to specify
all the properties for ~:recipe~. These will inherit the rest of its recipe
from Doom or MELPA/ELPA/Emacsmirror:

IE:
#+begin_src elisp :tangle no
(package! builtin-package :disable t)
#+end_src

You can override the recipe of a built in package without having to specify
all the properties for ~:recipe~. These will inherit the rest of its recipe
from Doom or MELPA/ELPA/Emacsmirror:

IE:
#+begin_src elisp :tangle no
(package! builtin-package :recipe (:nonrecursive t))
(package! builtin-package-2 :recipe (:repo "myfork/package"))
#+end_src

Specify a ~:branch~ to install a package from a particular branch or tag.
This is required for some packages whose default branch isn't ~master~ (which
our package manager can't deal with; see raxod502/straight.el#279)

IE:
#+begin_src elisp :tangle no
(package! builtin-package :recipe (:branch "develop"))
#+end_src

Use ~:pin~ to specify a particular commit to install.
IE:
#+begin_src elisp :tangle no
(package! builtin-package :pin "1a2b3c4d5e")
#+end_src

Doom's packages are pinned to a specific commit and updated from release to
release. The ~unpin!~ macro allows you to unpin single packages...

IE:
#+begin_src elisp :tangle no
(unpin! pinned-package)
; ...or multiple packages
(unpin! pinned-package another-pinned-package)
; ...Or *all* packages (NOT RECOMMENDED; will likely break things)
(unpin! t)
#+end_src

*** Declarations

So, finally, let's declare the packages we will use:

#+begin_src elisp :tangle packages.el
(package! org-edna)
(package! mozc)
#+end_src

And disable ones we don't use.
#+begin_src elisp :tangle packages.el
(package! ddskk ;; MOZC is better, consider contributing it to the japanese module.
  :disable t)
#+end_src

** config.el

*** Lexical binding

#+BEGIN_SRC elisp
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-
#+END_SRC


*** Personal information

Some functionality uses this to identify you, e.g. GPG configuration, email
clients, file templates and snippets.

#+begin_src elisp
(setq user-full-name "Daniel Levy Moreno"
      user-mail-address "daniellevymoreno@gmail.com")
#+end_src


*** Default font

Doom exposes five (optional) variables for controlling fonts in Doom. Here
are the three important ones:

+ ~doom-font~
+ ~doom-variable-pitch-font~
+ ~doom-big-font~ -- used for ~doom-big-font-mode~; use this for
  presentations or streaming.

They all accept either a font-spec, font string ("Input Mono-12"), or xlfd
font string. You generally only need these two:

IE:
#+begin_src elisp :tangle no
(setq doom-font (font-spec :family "monospace" :size 12 :weight 'semi-light)
      doom-variable-pitch-font (font-spec :family "sans" :size 13))
#+end_src

Let's choose our monospaced font, Roboto Mono goodness:
#+begin_src elisp
(setq doom-font (font-spec :family "monospace" :size 16 :name "Roboto Mono"))
#+end_src


*** Default theme

There are two ways to load a theme. Both assume the theme is installed and
available. You can either set ~doom-theme~ or manually load a theme with the
~load-theme~ function. This is the default:

#+begin_src elisp
(setq doom-theme 'doom-nord)
#+end_src

**** Nord powered aesthetics.

Let's add some small customizations, mostly make everything a bit brighter and bigger:

#+begin_src elisp
(use-package! doom-nord-theme
  :defer t
  :custom
  (doom-nord-brighter-modeline t)
  (doom-nord-padded-modeline t)
  (doom-nord-region-highlight 'frost))
#+end_src

*** Rainbow Delimeters

Matching pairs draw with the same face color, making them easily identifiable.

#+begin_src elisp
(add-hook! 'prog-mode-hook #'rainbow-delimiters-mode-enable)
#+end_src


*** Modeline

The default doom-modeline is great, the only thing is that I want it to show me
the evil state I am in with a letter instead of an icon:

#+begin_src elisp
(use-package! doom-modeline
  :defer t
  :custom
  (doom-modeline-modal-icon nil))
#+end_src

Also, the battery indicator is pretty neat:

#+begin_src elisp
(use-package! battery
  :hook
  (doom-modeline-mode . display-battery-mode))
#+end_src

*** TODO Perspective

*** Org

One of the killer features of emacs.

#+begin_src elisp
(use-package! org
    :defer t
#+end_src

If you use ~org~ and don't want your org files in the default location below,
change ~org-directory~. It must be set before org loads!

#+begin_src elisp
    :custom
    (org-directory "~/Cloud/org/")
#+end_src

Set ~org-attach-id-dir~ back to default value.

#+begin_src elisp
    (org-attach-id-dir  "data")
#+end_src

I only use one agenda file, that has all my rutine stuff in it.

#+begin_src elisp
    (org-agenda-files  `(,(expand-file-name "agenda.org" org-directory)))
#+end_src

Modules for keeping track of habits and completing checklists.

#+begin_src elisp
    (org-module  '(org-habit org-checklist))
#+end_src

Switch entry to 'DONE' when all subentries are done, to 'TODO' otherwise.

#+begin_src elisp
    :config
    (add-hook! 'org-after-todo-statistics-hook '(lambda (n-done n-not-done)
                          (let (org-log-done org-log-states)
                            (org-todo (if (= n-not-done 0) "DONE" "TODO")))))
#+end_src


Switch header 'TODO' state to 'DONE' when all checkboxes are ticked, to 'TODO'
otherwise

#+begin_src elisp
    (add-hook! 'org-checkbox-statistics-hook  '(lambda ()
                                             (let ((todo-state (org-get-todo-state)) beg end)
                                               (unless (not todo-state)
                                                 (save-excursion
                                                   (org-back-to-heading t)
                                                   (setq beg (point))
                                                   (end-of-line)
                                                   (setq end (point))
                                                   (goto-char beg)
                                                   (if (re-search-forward "\\[\\([0-9]*%\\)\\]\\|\\[\\([0-9]*\\)/\\([0-9]*\\)\\]"
                                                                          end t)
                                                       (if (match-end 1)
                                                           (if (equal (match-string 1) "100%")
                                                               (unless (string-equal todo-state "DONE")
                                                                 (org-todo 'done))
                                                             (unless (string-equal todo-state "TODO")
                                                               (org-todo 'todo)))
                                                         (if (and (> (match-end 2) (match-beginning 2))
                                                                  (equal (match-string 2) (match-string 3)))
                                                             (unless (string-equal todo-state "DONE")
                                                               (org-todo 'done))
                                                           (unless (string-equal todo-state "TODO")
                                                             (org-todo 'todo)))))))))))
#+end_src

More control ove how and when tasks change state.

#+begin_src elisp
(use-package! org-edna
  :hook
  '(org-mode . org-edna-mode))
#+end_src


*** Pretending we are in vim? That's just plain EVIL!

Bad puns aside, vim keybindings are hard to let go once you are used to them.
Luckily, doom comes with much of the heavy lifting already done when it comes to
evil mode. We just gotta customize some minor details.

#+begin_src elisp
(use-package! evil
  :defer t
  :custom
#+end_src

Make horizontal motions move to other lines.

#+begin_src elisp
  (evil-cross-lines t)
#+end_src

Remove highlighted items after search is finished.

#+begin_src elisp
  (evil-ex-search-persistent-highlight nil)
#+end_src

Universal argument mapped to M-u instead.

#+begin_src elisp
  :config
  (map! :g "M-u" #'universal-argument
#+end_src

Remove highlighted items after a search.

#+begin_src elisp
        :m "C-l" #'evil-ex-nohighlight))
#+end_src

*** Line-numbers

This determines the style of line numbers in effect. If set to ~nil~, line
numbers are disabled. For relative line numbers, set this to ~relative~.

#+begin_src elisp
(setq display-line-numbers-type 'relative)
#+end_src


*** Helpful

Let's make an global keybinding to find something I don't understand about emacs
quickly!

#+begin_src elisp
(map! :g "C-c C-d" #'helpful-at-point)
#+end_src

*** Which Key

Doom emacs default config is too slow, lets speed it up.

#+begin_src elisp
(use-package! which-key
  :defer t
  :custom
  (which-key-idle-delay 0.1)
  (which-key-idle-secondary-delay 0.2))
#+end_src

*** Customize Group

An essential interface to know what to customize!

#+begin_src elisp
(use-package! cus-edit
  :defer t
#+end_src

I mostly use it to know the customizable options in a package, chaging the
values within this configuration. So, let's make it show the actual real values.

#+begin_src elisp
  :custom
  (custom-unlispify-menu-entries nil)
  (custom-unlispify-tag-names nil)
  (custom-unlispify-remove-prefixes nil))
#+end_src

*** RSS, or how to get news the old-way.

First, lets bring our feeds into the cloud.

#+begin_src elisp
(use-package! elfeed
  :defer t
  :custom
  (elfeed-db-directory "~/Cloud/elfeed/")
#+end_src

Special faces for special tags.

#+begin_src elisp
  (elfeed-search-face-alist '((unread elfeed-search-unread-title-face)
                              (★      elfeed-search-unread-count-face)))
#+end_src


Show me entries from within a month that I haven't read.

#+begin_src elisp
  :config
  (setq elfeed-search-filter "@4-week-ago +unread "))
#+end_src


Give it an easy keybinding to access it:

#+begin_src elisp
(map! :leader :desc "RSS feed" :m "o e" #'elfeed)
#+end_src


And point elfeed to the org configuration file.

#+begin_src elisp
(use-package! elfeed-org
  :defer t
  :custom
  (rmh-elfeed-org-files (list (concat org-directory "elfeed.org"))))
#+end_src

Keybinding to easily find the feeds file.

#+begin_src elisp
(map! :leader
      :desc "RSS feed config" :m "o E" (lambda ()
                                          (interactive)
                                          (find-file (car rmh-elfeed-org-files))))
#+end_src

**** TODO Create =x= keybinding for =starring= (★) a register, in search map and show map

*** Japanese input.

I am learning japanese as a hobby, and I do most of my note taking in emacs. To input japanese text we use google's MOZC.

First, let's define our toggle function. Activates mozc mode and changes the modeline to show it.

#+begin_src elisp
;;;###autoload
(defun dan/toggle-mozc-mode ()
  "Toggle activation/deactivation of `mozc-mode'."
  (interactive)
  (let* ((active (mozc-mode))
         (msg-modeline (if active
                           '("Activated" . "日本語")
                         '("Deactivated" . ""))))
    (progn
      (message "Mozc Mode %s" (car msg-modeline))
      (setq global-mode-string (cdr msg-modeline))
#+end_src

This part is a bit of hack so mozc plays nicely with Doom's configuration of evil-org.

#+begin_src elisp
      (map! (:when (and (featurep 'evil-org) evil-org-mode) :map evil-org-mode-map
             (:when mozc-mode    :i "<return>"   nil)
             (:unless mozc-mode  :i "<return>"   (cmd! (org-return electric-indent-mode)))
             (:when mozc-mode    :i "RET"        nil)
             (:unless mozc-mode  :i "RET"        (cmd! (org-return electric-indent-mode))))))))
#+end_src

Let's lazy load mozc, so it loads only when our entry function is called.

#+begin_src elisp
(use-package! mozc
  :commands mozc-mode
#+end_src

The overlay style is sluggish, the echo-area style is pretty and very functional, it even works in the minibuffer!

#+begin_src elisp
  :custom
  (mozc-candidate-style 'echo-area))
#+end_src

Finally, we create a keybinding activate mozc-mode.

#+begin_src elisp
(map! :g "C-x j"  #'dan/toggle-mozc-mode
      :ni "C-x j" #'dan/toggle-mozc-mode)
#+end_src

**** TODO Prerequesites

Requires emacs_mozc_helper, this is how you install it:

*** Rust

Seems like rls is more stable than rust-analyzer.

#+begin_src elisp
(use-package! rustic
  :defer t
  :custom
  (rustic-lsp-server 'rls)
#+end_src

When using the rustic popup, be in emacs state.

**** TODO See if we can use ~set-popup-rules!~ to do this for us.

#+begin_src elisp
  :config
  (when (featurep 'evil)
    (add-hook! 'rustic-popup-mode-hook #'evil-emacs-state)))
#+end_src
