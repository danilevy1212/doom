# -*- eval: (progn (when (and (fboundp #'toc-org-mode) (not toc-org-mode)) (toc-org-mode)) (writeroom-mode +1)); -*-

#+TITLE: Dan's DOOM emacs configuration
#+OPTIONS: toc:nil tags:nil todo:nil

* Table Of Contents :TOC_9:
- [[#rationale][Rationale]]
  - [[#message-hello-s-emacs][~(message "Hello, %s!" "emacs")~]]
  - [[#distro-hopping-with-emacs-distros][Distro-hopping with emacs distros]]
  - [[#back-to-vanilla][Back to vanilla.]]
  - [[#why-doom][Why DOOM?]]
  - [[#tldr][TL;DR:]]
- [[#installation][Installation]]
  - [[#prerequisites][Prerequisites]]
  - [[#steps][Steps]]
- [[#configuration][Configuration]]
  - [[#initel][init.el]]
    - [[#lexical-binding][Lexical binding.]]
    - [[#doom-modules][~doom!~ modules]]
      - [[#input][:input]]
      - [[#completion][:completion]]
        - [[#company-mode][Company Mode]]
        - [[#ivy][Ivy]]
      - [[#ui][:ui]]
      - [[#editor][:editor]]
      - [[#emacs][:emacs]]
      - [[#term][:term]]
      - [[#checkers][:checkers]]
      - [[#tools][:tools]]
      - [[#tools-1][:tools]]
      - [[#lang][:lang]]
        - [[#rust][rust]]
          - [[#dependencies][Dependencies:]]
        - [[#sh][sh]]
        - [[#web][web]]
      - [[#email][:email]]
      - [[#app][:app]]
      - [[#config][:config]]
  - [[#packagesel][packages.el]]
    - [[#how-does-packagesel-work][How does packages.el work?]]
    - [[#declarations][Declarations]]
  - [[#autoload-folder][autoload folder]]
  - [[#configel][config.el]]
    - [[#personal-information][Personal information]]
    - [[#default-font][Default font]]
    - [[#default-theme][Default theme]]
      - [[#nord-powered-aesthetics][Nord powered aesthetics.]]
    - [[#splash-screen][Splash Screen]]
    - [[#rainbow-delimeters][Rainbow Delimeters]]
    - [[#modeline][Modeline]]
    - [[#projectile][Projectile]]
    - [[#dired][Dired]]
      - [[#autoloads][Autoloads]]
    - [[#org][Org]]
      - [[#org-edna][org-edna]]
      - [[#autoloads-1][Autoloads]]
    - [[#pretending-we-are-in-vim-thats-just-plain-evil][Pretending we are in vim? That's just plain EVIL!]]
    - [[#line-numbers][Line-numbers]]
    - [[#helpful][Helpful]]
    - [[#which-key][Which Key]]
    - [[#customize-group][Customize Group]]
    - [[#rss-or-how-to-get-news-the-old-way][RSS, or how to get news the old-way.]]
    - [[#mozc-japanese-input][Mozc (Japanese Input).]]
      - [[#autoloads-2][Autoloads]]
    - [[#rust-1][Rust]]
    - [[#web-mode][Web Mode]]
    - [[#nvm][nvm]]
      - [[#autoloads-3][Autoloads]]
    - [[#vue][Vue]]
    - [[#dotenv][Dotenv]]
  - [[#private-modules][Private modules.]]

* Rationale

During my undergraduate years, I remember having trouble setting up a postfix
server for a practical exercise in one of my classes. I had to edit the default
configuration file to harden the security of the system. My server was wrongly
configured and I couldn't figure out what part of my edits I had messed up. We
had to do all the changes to configuration file through a tty in an FreeBDS
virtual machine, so I was forced to use a terminal editor. =nano= was my choice
since it was similar to the other GUI editors I had used at the time. After much
frustration, I asked a professor of mine to please help me out. He took over my
seat, closed my =nano= session and reopened the conf file with a different editor.
He was pressing all sorts of keys on the keyboard at an amazing speed, the
cursor was flying all over the screen and I was simply at awe.

He found what was wrong with my config and fixed it, telling me what he had
changed. When he left, I tried to look up what command he had run to edit the
file. This was my first experience with... =vim=.  I was introduced to =emacs= a few
months later, when I saw a friend of mine taking some notes with it.

In any case, this is the earliest point that I can remember thinking that the
efficiency of text-editing, just like with any other task, is fully dependent on
the tool used to achieve it. Considering that I was on a professional path to
become a software engineer, a job that mostly consists of reading documentation,
source code and editing, I figured that it would pay off in the long run to take
some time to explore what editors were out there and make an educated choice for
a text editor, instead of just using whatever was popular.

** ~(message "Hello, %s!" "emacs")~

Having taken that decision, I played around with =vim= and later on with =emacs=,
finally settling with the former to write the code for my thesis. I started out
with a vanilla configuration, a single =.emacs= file where I would copy and paste
elisp from other people's config without much thinking.  It was ugly, messy and
buggy but It was also very fun. I loved the idea of using code to configure the
tool that I would use to edit code, so I stuck with it.

My knowledge of emacs would come from google searches, blog posts and the online
GNU Emacs documentation. I still hadn't learned how to ask emacs the things that
I didn't know (The invaluable C-h _).  Embarrasingly, I didn't learn that until
fairly late into my emacs usage history.  My editing needs were quite minimal so
even if my configuration didn't have all the bells and whistles of other
editors, It was good enough for me. I also knew, at least on a theoretical
level, that emacs had very few limits when it came to extensibility. Emacs can
interact with the OS to do just about anything, which explains part of the
popular saying that refers to emacs as "A great OS, if only missing a good text
editor".

When I got frustrated with emacs because I broke it somehow or I didn't know how
to do something with it, the potential of emacs as an almost infinitely
extensible editor always kept me from switching editors and moving on. Even now,
is this fact that keeps me going back to it.

** Distro-hopping with emacs distros

Life changes and so do our needs. I got my first full-time job as Web Developer
and emacs had to level up to a robust daily driver. I had to use many different
technologies in a project with continuously changing requirements.  My cute
emacs experiment could not keep up and I was forced on using other editors to be
able to push the work out.  However, I was always missing aspects of emacs when
using  other editors, like the frame, buffer and window model, the automatic
backup files or just the simple fact that I could change almost any aspect of my
emacs if I so desired.

I would still open up emacs for magit when interacting with git or for org-mode
as my todo app. However, I wanted to use emacs for more than that. Emacs shines
when you know what you want from it. However, It can be very daunting and take a
lot of work to set up a configuration for "general" programming purposes.  Which
packages are good? Which are compatible with what you have? When two or more
packages are similar, how do you decide which one to use? If emacs was to be my
daily driver, I would have to answer this questions often, which implies
research, time and effort.

_Why work on problems that others have already solved?_ With this in mind, I
decided to try out =spacemacs=, a community developed emacs distribution full of
pre-configured packages grouped by =layers=. And for a while, It worked out great.
The defaults were good, it was functional enough and it could keep up with the
technologies I was using at work. What was not to love? Well, with continuous
use the wrinkles started to appear. For one, =spacemacs= was slow. It would take a
long time to startup and commands were noticeably sluggish. It was also pretty
buggy.  Sure, the layers for different languages worked reasonably well but from
time to time emacs would behave in unexpected ways and I would have no idea why.

Looking into ways of making =spacemacs= faster, I stumbled upon =doom= and decided
to try it out. I was impressed (and I still am) with its speed, at startup and
during use, it feels quick and snappy. Installing =doom= modules was similar
enough to configuring =spacemacs= layers. While =doom= was not by any means buggy, I
would get frustrated with it's opinionated defaults.  =doom= would have some
keybinding I didn't like or some package had some extra behaviour different to
what I was used to and I wouldn't know how to change it to what I wanted.

** Back to vanilla.

At this point it was clear to me what was the real problem. My ignorance of the
inner workings on emacs was my only limiting factor. So I took an extreme
position, I went back to pure vanilla again, discarding all my previous
configurations and starting from scratch, while using other editors for my job.
My objective was to recreate the aspects that I liked from =doom= from scratch in
my own configuration. Very naive, but I was motivated.

I took it slow, researching Emacs throughly and little by little building my
configuration, but trying to understand everything that I was chaging. I read
[[https://www.masteringemacs.org/][Mickey Peterson's Mastering Emacs]], where I finally learned how to ask emacs
about the things I don't understand. I found the excellent [[http://ergoemacs.org/][Xah's ergoemacs]] blog,
an awesome reference I keep consulting even now with all sorts of information on
elisp syntax, emacs concepts and configuration tips and tricks.

I started following members of the awesome emacs community, such as [[https://protesilaos.com/dotemacs/][Protesilaos
Stavrou]], a long term =vim= user transformed into a hardcore emacs user, whose
videos explaining his configuration where a great inspiration for me and taught
me to favour built-in packages over third party packages and most importantly,
how to build my own criteria for what packages I should use.

It took at least two months until I made a configuration that I could use at
work again, but it felt great when I finally managed to have something that was
reasonably fast, reproducible in any computer running linux and was functional
enough for my use cases that I had made and I intimately understood!  Although I
am nowhere near a emacs expert, if such a thing exists, and a lot of details
still escape me. I learned a LOT about not only emacs, but about lisp,
functional programming and free (as in freedom) extensible software! Going back
to basics paid of in spades.

** Why DOOM?

I'll ask again, _Why work on problems that others have already solved?_. Well, in
my case, It was to learn more about the problem-context.  The thing is, emacs is
truly immense, even if we don't take into account all the third party packages
written for it. It has it's own lisp dialect for extensibility, a =mode= system
for defining unique behaviour in each buffer, with =major modes= (one per buffer)
and =minor modes= (can be multiple or none in a buffer) that change the visual
elements, available commands and keybindings and it has different systems to
detect when and which of this modes it should activate at any given time. It
also has different ways of running system commands synchronously or
asynchronously and processing their output. It even has a process manager for
the programs running under emacs!

I'm not even being exaustive. Add to that 40 years of packages and multiple
emacs releases! This wouldn't be so troublesome if it weren't for the terrible
defaults with which emacs installs. Ugly default theme and questionable default
bindings aside, it is terribly unoptimized for modern systems slowing down
performance. During my vanilla adventure, a lot of my time was just spent trying
to make emacs feel more modern and fast, which is very time consuming.  As a bit
of tangent, I am suprised that packages such as gchm and use-package don't come
preinstalled with emacs as they are incredible time savers, not just with
performance but also in configuration time...

At the beginning of reconfiguring my vanilla emacs, after addressing the
terrible defaults, the problems I was trying to solve were interesting, perhaps
because it was my first time trying to solve them. Things like "What's the best
moment to lazy load this package?", "How do I write Spanish accents in emacs?"
or "How should I structure my .el files directory?". As the configuration grew,
more and more problems started appearing. Nothing major that broke my workflow
but annoyances none the less. I would write =FIXME= comments in my .el files to
keep track of this problems so I could fix them later.

When I wanted to set up emacs for a new language environments, I would spend a
lot of time checking out what community packages there were for that especific
environment, putting =TODO= comments with the projects repository url so I could
try out and configure it out later on. Quickly It became the case that for every
=FIXME= or =TODO= comment I would solve, two or three more would appear.

The =FIXME= were not such a big deal, I like hunting bugs and fixing them, since I
always feel like I atleast learn something in the process.  The big problems
were the =TODO=, which were not remotly as interesting to solve. Looking for
packages is time consuming and many times I ended up not using what I tried out.
Other times, the packages I was interested in were so massive I never wanted to
because I knew It would take a long time to really configure it like I wanted
to. Honorable mentions in this categories are =lsp= and =treemacs=.

#+HTML: <p align="center"><img src="https://raw.githubusercontent.com/danilevy1212/doom/master/img/too-many-todos.png"/></p>
#+HTML: <p align="center">Unresolved issues in my vanilla configuration.</p>

So, _Why work on problems that others have already solved?_. Not all problems are
made equally and some problems are just tedious to solve, this is the principal
reason why I choose to go back to =doom=. Another reason is that I strongly agree
with the project guiding principals. =doom= is not and IDE replacement or a you
get what you see type of editor. It's fully expected of its users to customize
it and all its functionality is opened to the user so it can be tinkered with.
No magic, just very well thought out elisp macros and hooks!

This is perhaps what I like the most about =doom=, its true power resides in it's
=core= module, where all the macros, functions and hooks used to help the user
extend emacs resides. The =modules= in =doom= just use those set of tools to offer
configuration options for specific use cases. This offers a mix of the best of
both the worlds of vanilla emacs and spacemacs. With =doom= I can try out a
module, see what I like, bring it over to my configuration, disable packages
that I don't like and mix them with my own packages in a quick and reliable
manner, much more so that If I were back in vanilla emacs.

** TL;DR:

[[https://blog.jethro.dev/posts/migrating_to_doom_emacs/][It offers reasonable defaults and lots of functionality without sacrificing extensability or performance]]

* Installation

** Prerequisites

- Git 2.23+
- Emacs 26.1+ *(27.x is recommended)*
- [[https://github.com/BurntSushi/ripgrep][ripgrep]] 11.0+
- GNU Find
- (Optional) [[https://github.com/sharkdp/fd][fd]] 7.3.0+ (known as ~fd-find~ on Debian, Ubuntu & derivatives) --
  improves performance for many file indexing commands

Additionally, the =doom= executable (located at ~user-emacs-directory/bin/doom~)
can be called with the =doctor= argument to obtain information of posible
missing dependencies used by the modules.

** Steps

First, clone this repository in your ~DOOMDIR~. ~DOOMDIR~ is an environment variable
that points to the location of your private configuration. If ~DOOMDIR~ does not
exist, =doom= will look for your configuration in =doom.d=.

#+begin_src shell :tangle no
export DOOMDIR=/path/to/doom/dir
#+end_src

With the following command you can clone the repository in either case:

#+begin_src shell :tangle no
git clone https://github.com/danilevy1212/doom.git ${DOOMDIR:-~/.doom.d}
#+end_src

Then, just follow the instructions for installing [[https://github.com/hlissner/doom-emacs#install][doom emacs]]. In case you have
set ~DOOMDIR~, make sure to run ~doom env~ before ~doom install~.

* Configuration

Blocks preceded with =IE= are just examples that are not evaluated, the rest of
the blocks are put in the filename of the corresponding heading.

** init.el

This file controls what Doom modules are enabled and what order they load
in. Remember to run ~doom sync~ after modifying it!

*** Lexical binding.

Elisp by default has dynamic-scope, which is fine if a little weird. However,
dynamic scope comes with a performance penalty. Optional lexical scope has to be
activated with a file parameter, as such:

#+begin_src elisp :tangle init.el
;;; $DOOMDIR/init.el -*- lexical-binding: t; -*-
#+end_src

This options has to be activated in a per file basis, so it's hardly the last
time we will use these block of code.

*** TODO ~doom!~ modules

The ~doom!~ macro controls which modules are loaded into doom emacs. Modules are
package configurations made by the community. In the spirit of emacs, all the
configuration that comes with a particular module can be extended or even completly
overwritten by your private config.

Modules are completly open for discovery. Press 'SPC h d h' (or 'C-h d h' for
non-vim users) to access Doom's documentation. There you'll find a "Module
Index" link where you'll find a comprehensive list of Doom's modules and what
flags they support.

Alternatively, press 'gd' (or 'C-c c d') on a module to browse its directory
(for easy access to its source code).

The ~doom!~ macro is capable of some conditional logic, thanks to the ~:if~ and
~:cond~ keywords.  Unfortunately, these keywords are not well documented beyond
and example in the docs. The rest of the keywords match with a directory location.
The symbols following a keyword are a module that reside in said directory.

A module is structurely similar to the ~$DOODIR~ folder. Defines a packages.el
and config.el in the very least, plus autoloads and such. Some modules are
documented with a ~README.org~, many others are not, so it's important to take a
look a the source code, see what they define and configure, before deciding to
use a module.

Some modules can be wrapped in a list and given 'flags', that activate extra
optional configuration. The list must have the module name as the car, the flags
as the tail.

**** :input

I was tempted to use the ~japanese~ module but only ~pangu spacing~ seems like a
package I could use, so I rather install it standalone.

#+begin_src elisp :tangle init.el
(doom! :input
       ;;chinese
       ;;japanese
       ;;layout            ; auie,ctsrnm is the superior home row
#+end_src

**** :completion

***** Company Mode

In my opinion, this package offers such a boost in productivity it's almost
essential. Sure, the overlay can be distracting for some, but it's very
unintrusive and completly optional while being a very good tool for
discoverability.

#+begin_src elisp :tangle init.el
       :completion
       (company +childframe)  ; the ultimate code completion backend
#+end_src

Doom offers a bunch of neat little extras. For starters, =+childframe= flag
configures the company overlay to live in its own frame, which looks nicer
in the GUI.

By default, completion is triggered after a short idle period or with the
=C-SPC= key. While the popup is visible, the following keys are available:

| Keybind | Description                              |
|---------+------------------------------------------|
| =C-n=     | Go to next candidate                     |
| =C-p=     | Go to previous candidate                 |
| =C-j=     | (evil) Go to next candidate              |
| =C-k=     | (evil) Go to previous candidate          |
| =C-h=     | Display documentation (if available)     |
| =C-u=     | Move to previous page of candidates      |
| =C-d=     | Move to next page of candidates          |
| =C-s=     | Filter candidates                        |
| =C-S-s=   | Search candidates with helm/ivy          |
| =C-SPC=   | Complete common                          |
| =TAB=     | Complete common or select next candidate |
| =S-TAB=   | Select previous candidate                |

In the spirit of Vim's omni-completion, the following insert mode keybinds are
available to evil users to access specific company backends:

| Keybind | Description                       |
|---------+-----------------------------------|
| =C-x C-]= | Complete etags                    |
| =C-x C-f= | Complete file path                |
| =C-x C-k= | Complete from dictionary/keyword  |
| =C-x C-l= | Complete full line                |
| =C-x C-o= | Invoke complete-at-point function |
| =C-x C-n= | Complete next symbol at point     |
| =C-x C-p= | Complete previous symbol at point |
| =C-x C-s= | Complete snippet                  |
| =C-x s=   | Complete spelling suggestions     |

Completion candidates are supplied by the functions defined in
~company-backends~. Doom offers a helper macro, ~set-company-backend!~ to change
the value of a ~company-backends~ for a specific major/minor mode locally in the
buffer.  Some examples of how to use it can be found in the
~set-company-backend!~ documentation.

***** Ivy

Another super useful package. Ivy is a completion engine that looks deceptively
simple. Creating new search types is simple through it's [[https://oremacs.com/swiper/#api][API]] and has a lot
community packages that extend it. Ivy also comes with it's own Info node where
it details more of it's functionality.

This module offers a lot unique search commands through the =SPC s= and =SPC f=
prefixes. If the commands are prefixed with the universal command (=SPC u=),
their result with include hidden files.

For use evil users, it also offers a nice ex-command:

| ex command           | description                                                    |
|----------------------+----------------------------------------------------------------|
| ~:pg[rep][!] [query]~  | search project (if ~!~, include hidden files)                    |
| ~:pg[rep]d[!] [query]~ | search from current directory (if ~!~, don't search recursively) |

The optional `!` is equivalent to the universal argument for the previous
commands.

We take icons with the flags:

+ +icons :: all-the-icons niceties in the ivy buffer.
+ +fuzzy  :: Search for "close enough" matches.
+ +prescient :: Order candidate by selection frequency.

#+begin_src elisp :tangle init.el
       ;;helm              ; the *other* search engine for love and life
       ;;ido               ; the other *other* search engine...
       (ivy +icons +fuzzy +prescient)        ; a search engine for love and life
#+end_src

**** TODO :ui

#+begin_src elisp :tangle init.el
       :ui
       ;;deft              ; notational velocity for Emacs
       doom              ; what makes DOOM look the way it does
       doom-dashboard    ; a nifty splash screen for Emacs
       doom-quit         ; DOOM quit-message prompts when you quit Emacs
       ;;fill-column       ; a `fill-column' indicator
       hl-todo           ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
       ;;hydra
       ;;indent-guides     ; highlighted indent columns
       ;;ligatures         ; ligatures and symbols to make your code pretty again
       ;;minimap           ; show a map of the code on the side
       modeline          ; snazzy, Atom-inspired modeline, plus API
       ;;nav-flash         ; blink cursor line after big motions
       ;;neotree           ; a project drawer, like NERDTree for vim
       ophints           ; highlight the region an operation acts on
       (popup +defaults)   ; tame sudden yet inevitable temporary windows
       ;;tabs              ; a tab bar for Emacs
       ;;treemacs          ; a project drawer, like neotree but cooler
       ;;unicode           ; extended unicode support for various languages
       vc-gutter         ; vcs diff in the fringe
       vi-tilde-fringe   ; fringe tildes to mark beyond EOB
       ;;window-select     ; visually switch windows
       workspaces        ; tab emulation, persistence & separate workspaces
       zen               ; distraction-free coding or writing
#+end_src

**** TODO :editor

#+begin_src elisp :tangle init.el
       :editor
       (evil +everywhere); come to the dark side, we have cookies
       file-templates    ; auto-snippets for empty files
       fold              ; (nigh) universal code folding
       ;;(format +onsave)  ; automated prettiness
       ;;god               ; run Emacs commands without modifier keys
       ;;lispy             ; vim for lisp, for people who don't like vim
       ;;multiple-cursors  ; editing in many places at once
       ;;objed             ; text object editing for the innocent
       ;;parinfer          ; turn lisp into python, sort of
       ;;rotate-text       ; cycle region at point between text candidates
       snippets          ; my elves. They type so I don't have to
       ;;word-wrap         ; soft wrapping with language-aware indent
#+end_src

**** TODO :emacs

#+begin_src elisp :tangle init.el
       :emacs
       (dired +icons)    ; making dired pretty [functional]
#+end_src

=dired-mode=, as configured in the =dired= module, has only a few extra bells and
whistles added. Apart from aesthetic stuff, there are some extra keybindings:

| Keybind | Description                |
|---------+----------------------------|
| =SPC f d= | Find directory with dired  |
| =q=       | Exit dired buffer          |
| =C-c C-r= | Run =dired-rsync=            |
| =C-c C-e= | Rename entries with =wdired= |

Which complement the [[https://www.gnu.org/software/emacs/refcards/pdf/dired-ref.pdf][default keybindings]].

#+begin_src elisp :tangle init.el
       electric          ; smarter, keyword-based electric-indent
       ;;ibuffer         ; interactive buffer management
       undo              ; persistent, smarter undo for your inevitable mistakes
       vc                ; version-control and Emacs, sitting in a tree
#+end_src

**** TODO :term

#+begin_src elisp :tangle init.el
       :term
       ;;eshell            ; the elisp shell that works everywhere
       ;;shell             ; simple shell REPL for Emacs
       ;;term              ; basic terminal emulator for Emacs
       vterm             ; the best terminal emulation in Emacs
#+end_src

**** TODO :checkers

#+begin_src elisp :tangle init.el
       :checkers
       syntax              ; tasing you for every semicolon you forget
       ;; spell             ; tasing you for misspelling mispelling
       ;; grammar           ; tasing grammar mistake every you make
#+end_src

**** TODO :tools
#+begin_src elisp :tangle init.el
       :tools
       ;;ansible
       ;;debugger          ; FIXME stepping through code, to help you add bugs
       ;;direnv
       ;;docker
       ;;editorconfig      ; let someone else argue about tabs vs spaces
       ;;ein               ; tame Jupyter notebooks with emacs
       (eval +overlay)     ; run code, run (also, repls)
       ;;gist              ; interacting with github gists
       lookup              ; navigate your code and its documentation
       (lsp +peek)
       magit             ; a git porcelain for Emacs
       ;;make              ; run make tasks from Emacs
       ;;pass              ; password manager for nerds
       pdf               ; pdf enhancements
       ;;prodigy           ; FIXME managing external services & code builders
       ;;rgb               ; creating color strings
       ;;taskrunner        ; taskrunner for all your projects
       ;;terraform         ; infrastructure as code
       ;;tmux              ; an API for interacting with tmux
       ;;upload            ; map local to remote projects via ssh/ftp
#+end_src

**** TODO :tools
#+begin_src elisp :tangle init.el
       :os
       ;;(:if IS-MAC macos)  ; improve compatibility with macOS
       ;;tty               ; improve the terminal Emacs experience
#+end_src

**** TODO :lang

#+begin_src elisp :tangle init.el
       :lang
       ;;agda              ; types of types of types of types...
       ;;cc                ; C/C++/Obj-C madness
       ;;clojure           ; java with a lisp
       ;;common-lisp       ; if you've seen one lisp, you've seen them all
       ;;coq               ; proofs-as-programs
       ;;crystal           ; ruby at the speed of c
       ;;csharp            ; unity, .NET, and mono shenanigans
       ;;data              ; config/data formats
       ;;(dart +flutter)   ; paint ui and not much else
       ;;elixir            ; erlang done right
       ;;elm               ; care for a cup of TEA?
       emacs-lisp        ; drown in parentheses
       ;;erlang            ; an elegant language for a more civilized age
       ;;ess               ; emacs speaks statistics
       ;;faust             ; dsp, but you get to keep your soul
       ;;fsharp            ; ML stands for Microsoft's Language
       ;;fstar             ; (dependent) types and (monadic) effects and Z3
       ;;gdscript          ; the language you waited for
       ;;(go +lsp)         ; the hipster dialect
       ;;(haskell +dante)  ; a language that's lazier than I am
       ;;hy                ; readability of scheme w/ speed of python
       ;;idris             ;
       ;;json              ; At least it ain't XML
       ;;(java +meghanada) ; the poster child for carpal tunnel syndrome
       (javascript +lsp)   ; all(hope(abandon(ye(who(enter(here))))))
       ;;julia             ; a better, faster MATLAB
       ;;kotlin            ; a better, slicker Java(Script)
       ;;latex             ; writing papers in Emacs has never been so fun
       ;;lean
       ;;factor
       ;;ledger            ; an accounting system in Emacs
       ;;lua               ; one-based indices? one-based indices
       markdown          ; writing docs for people to ignore
       ;;nim               ; python + lisp at the speed of c
       ;;nix               ; I hereby declare "nix geht mehr!"
       ;;ocaml             ; an objective camel
       org               ; organize your plain life in plain text
       ;;php               ; perl's insecure younger brother
       ;;plantuml          ; diagrams for confusing people more
       ;;purescript        ; javascript, but functional
       (python +lsp +pyright) ; beautiful is better than ugly
       ;;qt                ; the 'cutest' gui framework ever
       ;;racket            ; a DSL for DSLs
       ;;raku              ; the artist formerly known as perl6
       ;;rest              ; Emacs as a REST client
       ;;rst               ; ReST in peace
       ;;(ruby +rails)     ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
#+end_src


***** rust

Rustic mode is great and the integrates really well with cargo. The defaults are
reasonable and with the =+lsp= it integrates nicely with lsp, what's not to
love?

#+begin_src elisp :tangle init.el
       (rust +lsp)         ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
#+end_src

****** Dependencies:

Requires [[https://github.com/rust-lang/rls][rls]] or [[https://rust-analyzer.github.io/manual.html#installation][rust-analyzer]], both obtainable with [[https://github.com/rust-lang/rustup][rustup]]. I always use =rls=.

***** TODO sh

#+begin_src elisp :tangle init.el
       ;;scala             ; java, but good
       ;;scheme            ; a fully conniving family of lisps
       sh                  ; she sells {ba,z,fi}sh shells on the C xor
#+end_src

***** TODO web

#+begin_src elisp :tangle init.el
       ;;sml
       ;;solidity          ; do you need a blockchain? No.
       ;;swift             ; who asked for emoji variables?
       ;;terra             ; Earth and Moon in alignment for performance.
       (web +lsp)          ; the tubes
       ;;yaml              ; JSON, but readable
#+end_src

**** TODO :email

#+begin_src elisp :tangle init.el
       :email
       ;;(mu4e +gmail)
       ;;notmuch
       ;;(wanderlust +gmail)
#+end_src

**** TODO :app

#+begin_src elisp :tangle init.el
       :app
       ;;calendar
       ;;irc               ; how neckbeards socialize
       (rss +org)        ; emacs as an RSS reader
       ;;twitter           ; twitter client https://twitter.com/vnought
#+end_src

**** TODO :config

#+begin_src elisp :tangle init.el
       :config
       literate
       (default +bindings +smartparens))
#+end_src

** packages.el

*** How does packages.el work?

To install a package with Doom you must declare them here and run ~doom sync~
on the command line, then restart Emacs for the changes to take effect -- or
use ~M-x doom/reload~.

To install SOME-PACKAGE from MELPA, ELPA or emacsmirror:

ie:
#+begin_src elisp :tangle no
(package! some-package)
#+end_src

To install a package directly from a remote git repo, you must specify a
~:recipe~. You'll find documentation on what ~:recipe~ accepts here:
https://github.com/raxod502/straight.el#the-recipe-format

ie:
#+begin_src elisp :tangle no
(package! another-package
  :recipe (:host github :repo "username/repo"))
#+end_src

If the package you are trying to install does not contain a PACKAGENAME.el
file, or is located in a subdirectory of the repo, you'll need to specify
~:files~ in the ~:recipe~:

ie:
#+begin_src elisp :tangle no
(package! this-package
  :recipe (:host github :repo "username/repo"
           :files ("some-file.el" "src/lisp/*.el")))
#+end_src

If you'd like to disable a package included with Doom, you can do so here
with the ~:disable~ property:

ie:
#+begin_src elisp :tangle no
(package! builtin-package :disable t)
#+end_src

You can override the recipe of a built in package without having to specify
all the properties for ~:recipe~. These will inherit the rest of its recipe
from Doom or MELPA/ELPA/Emacsmirror:

ie:
#+begin_src elisp :tangle no
(package! builtin-package :disable t)
#+end_src

You can override the recipe of a built in package without having to specify
all the properties for ~:recipe~. These will inherit the rest of its recipe
from Doom or MELPA/ELPA/Emacsmirror:

ie:
#+begin_src elisp :tangle no
(package! builtin-package :recipe (:nonrecursive t))
(package! builtin-package-2 :recipe (:repo "myfork/package"))
#+end_src

Specify a ~:branch~ to install a package from a particular branch or tag.
This is required for some packages whose default branch isn't ~master~ (which
our package manager can't deal with; see raxod502/straight.el#279)

ie:
#+begin_src elisp :tangle no
(package! builtin-package :recipe (:branch "develop"))
#+end_src

Use ~:pin~ to specify a particular commit to install.
ie:
#+begin_src elisp :tangle no
(package! builtin-package :pin "1a2b3c4d5e")
#+end_src

Doom's packages are pinned to a specific commit and updated from release to
release. The ~unpin!~ macro allows you to unpin single packages...

ie:
#+begin_src elisp :tangle no
(unpin! pinned-package)
; ...or multiple packages
(unpin! pinned-package another-pinned-package)
; ...Or *all* packages (NOT RECOMMENDED; will likely break things)
(unpin! t)
#+end_src

*** Declarations

For convinience, packages will be declared in code blocks close to their
configuration code blocks. Package declaration blocks actually go to into
=packages.el=.  Package declarations blocks can be distinguished for only
containing the ~package!~ macro.

We don't permit the package.el file to be byte compiled and declare its
lexical binding.

#+begin_src elisp :tangle packages.el
;; -*- no-byte-compile: t; lexical-binding:t; -*-
;;; $DOOMDIR/packages.el
#+end_src


** autoload folder

Autoloads blocks go into different files in the =autoload= folder.  In this
folder there are several files which define functions that shouldn't be loaded
until they're needed and logic that should be autoloaded (evaluated very, very
early at startup).

This is all made possible thanks to the autoload cookie: ~;;;###autoload~.
Placing this on top of a lisp form will do one of two things:

1. Add a ~autoload~ call to Doom's autoload file (found in
   =~/.emacs.d/.local/autoloads.el=, which is read very early in the startup
   process).
2. Or copy that lisp form to Doom's autoload file verbatim (usually the case for
   anything other then ~def*~ forms, like ~defun~ or ~defmacro~).

Doom's autoload file is generated by scanning these files when you execute ~doom
sync~.

As with package declarations blocks, autoload code blocks will be placed close
to their related configuration blocks. These will be placed in a autoload
subheading within the corresponding package heading.

** config.el

Most of the configuration is written here. In =config.el= we further customize
the packages from the different modules and in =packages.el=. In other words, the
real fun starts here.  As always, we start by declaring the lexical binding:

#+BEGIN_SRC elisp
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-
#+END_SRC

*** Personal information

Some functionality uses this to identify you, e.g. GPG configuration, email
clients, file templates and snippets.

#+begin_src elisp
(setq user-full-name "Daniel Levy Moreno"
      user-mail-address "daniellevymoreno@gmail.com")
#+end_src

*** Default font

Doom exposes five (optional) variables for controlling fonts in Doom. Here
are the three important ones:

+ ~doom-font~
+ ~doom-variable-pitch-font~
+ ~doom-big-font~ -- used for ~doom-big-font-mode~; use this for
  presentations or streaming.

They all accept either a font-spec, font string ("Input Mono-12"), or xlfd
font string. You generally only need these two:

ie:
#+begin_src elisp :tangle no
(setq doom-font (font-spec :family "monospace" :size 12 :weight 'semi-light)
      doom-variable-pitch-font (font-spec :family "sans" :size 13))
#+end_src

Let's _choose_ our *monospaced* font, /Hack/ goodness:

#+begin_src elisp
(setq doom-font (font-spec :family "Hack" :size 16))
#+end_src

And our =variable pitch= +font+, ~DejaVu Sans~:

#+begin_src elisp :tangle no
(setq doom-variable-pitch-font (font-spec :family "DejaVu Sans" :size 20))
#+end_src

Comments and keywords should pop more...

#+begin_src elisp
(custom-set-faces!
  '(font-lock-comment-face :slant italic)
  '(font-lock-keyword-face :slant italic))
#+end_src

When in zen mode, scale text just a bit.

#+begin_src elisp
(after! writeroom-mode
  (setq +zen-text-scale 1.25))
#+end_src

*** Default theme

There are two ways to load a theme. Both assume the theme is installed and
available. You can either set ~doom-theme~ or manually load a theme with the
~load-theme~ function. This is the default:

#+begin_src elisp
(setq doom-theme 'doom-nord)
#+end_src

**** Nord powered aesthetics.

Let's add some small customizations, mostly make everything a bit brighter and bigger:

#+begin_src elisp
(use-package! doom-nord-theme
  :defer t
  :custom
  (doom-nord-brighter-modeline t)
  (doom-nord-padded-modeline t)
  (doom-nord-region-highlight 'frost))
#+end_src

*** Splash Screen

Default doom dashboard is pretty and welcoming, let's just give it a small personal touch.

#+begin_src elisp
(setq fancy-splash-image (expand-file-name "img/stallman.png" doom-private-dir))
#+end_src

Paying respects to both the spirit of emacs and its creator.

#+HTML: <p align="center"><img src="https://raw.githubusercontent.com/danilevy1212/doom/master/img/stallman.png"/></p>

*** Rainbow Delimeters

Matching pairs draw with the same face color, making them easily identifiable.

#+begin_src elisp
(add-hook! prog-mode #'rainbow-delimiters-mode-enable)
#+end_src

*** Modeline

The default doom-modeline is great, the only thing is that I want it to show me
the evil state I am in with a letter instead of an icon:

#+begin_src elisp
(use-package! doom-modeline
  :defer t
  :custom
  (doom-modeline-modal-icon nil))
#+end_src

We would like to display the battery icon in the modeline, but only if I am in
a laptop:

#+begin_src elisp
(use-package! battery
  :after-call doom-modeline-mode
  :config
  (when (and battery-status-function
             (not (string-match-p "N/A"
                                  (battery-format "%B"
                                                  (funcall battery-status-function)))))
    (display-battery-mode)))
#+end_src

*** Projectile

Let's make projectile's life easier by giving it some paths where I normally
store projects.

#+begin_src elisp
(setq projectile-project-search-path '("~/Projects/" "~/.config/"))
#+end_src

*** Dired

One thing really missing from the default configuration of =dired= is an easy
way to move up and down from directories.

#+begin_src elisp
(after! dired
  (map! :map dired-mode-map
        :n "h" #'dired-up-directory
        :n "l" #'dired-find-file
#+end_src

Also add a way to jump into dired in another window.

#+begin_src elisp
        :leader
        :n "o _" #'dired-jump-other-window)
#+end_src

Most of the information dired throws at you is not really necessary, so let's
hide it by default. One can toggle this information on/off with ~(~ keybinding.

#+begin_src elisp
  (add-hook! dired-mode #'dired-hide-details-mode)
#+end_src

But, do show git information on repos by default, can be toggled on/off with ~)~.

#+begin_src elisp
   (add-hook! 'dired-after-readin-hook #'+dired-enable-git-info-h))
#+end_src

Opening files from dired with an external program is a bit of drag by default, so
we add the =dired-open= package to take care of that.

#+begin_src elisp :tangle packages.el
(package! dired-open)
#+end_src

The variable ~dired-open-guess-shell-alist~ determines if the file is opened with
an external program.

#+begin_src elisp
(use-package! dired-open
  :after dired
  :custom
  (dired-open-functions (list #'dired-open-guess-shell-alist
                              #'dired-open-by-extension
                              #'dired-open-subdir)))
#+end_src

**** Autoloads

I use ~dired-jump-other-window~ quite frequently and it's annoying when the
created window doesn't close with the dired buffer. Thus, I created this small
wrapper to solve this problem.

#+begin_src elisp :mkdirp yes :tangle autoload/dired.el
;;; $DOODIR/autoload/dired.el -*- lexical-binding: t; -*-

;;;###autoload
(defun dan/dired-quit-all ()
  "Kill all dired buffers and close the dired window."
  (interactive)
  (let ((windows-n (length (window-list))))
    (when (> windows-n 1)
      (delete-windows-on (current-buffer)))
    (+dired/quit-all)))
#+end_src

And now just override the default.

#+begin_src elisp
(after! dired
  (map! :map dired-mode-map
        :n "q" #'dan/dired-quit-all))
#+end_src

*** Org

One of the killer features of emacs.

#+begin_src elisp
(use-package! org
    :defer t
#+end_src

If you use ~org~ and don't want your org files in the default location below,
change ~org-directory~. It must be set before org loads!

#+begin_src elisp
    :custom
    (org-directory "~/Cloud/org/")
#+end_src

Set ~org-attach-id-dir~ back to default value.

#+begin_src elisp
    (org-attach-id-dir  "data")
#+end_src

I only use one agenda file, that has all my rutine stuff in it.

#+begin_src elisp
    (org-agenda-files  `(,(expand-file-name "agenda.org" org-directory)))
#+end_src

Make emphasis markers autohide

#+begin_src elisp
    (org-hide-emphasis-markers t)
#+end_src

Modules for keeping track of habits and completing checklists.

#+begin_src elisp
    (org-module  '(org-habit org-checklist))
#+end_src

Add custom functions to some org hooks. First, a function to be runned when
subheading change KEYWORD state.

#+begin_src elisp
    :config
    (add-hook! 'org-after-todo-statistics-hook #'dan/org-after-todo-statistics-preserve-todo-state)
#+end_src

I like my org files to not exceed the ~fill-collumn~ limit, so for them I activate
~auto-fill-mode~.

#+begin_src elisp
    (add-hook! org-mode #'auto-fill-mode)
#+end_src

In org buffers, remove the line number fringe.

#+begin_src elisp
    (add-hook! org-mode (setq-local display-line-numbers nil))
#+end_src

Switch header 'TODO' state to 'DONE' when all checkboxes are ticked, to 'TODO'
otherwise

#+begin_src elisp
    (add-hook! 'org-checkbox-statistics-hook  #'dan/org-checkbox-statistics-change-to-done-when-all-ticked))
#+end_src

**** org-edna

=org-edna= offers more control ove how and when tasks change state and manages
dependencies between tasks through extra heading proporties.

#+begin_src elisp :tangle packages.el
(package! org-edna)
#+end_src

Load and activate org-edna together with org-mode.

#+begin_src elisp
(use-package! org-edna
  :hook
  '(org-mode . org-edna-mode)
#+end_src

Make =org-edna= to trigger in any state change except done.

#+begin_src elisp
  :custom
  (org-edna-from-todo-states 'not-done))
#+end_src

**** Autoloads

Lexical Binding.

#+begin_src elisp :tangle autoload/org.el :mkdirp yes
;;; $DOOMDIR/autoload/org.el -*- lexical-binding: t; -*-
#+end_src

Define the custom function, switch entry to 'DONE' when all subentries are
'DONE', else keep entry original todo state.

#+begin_src elisp :tangle autoload/org.el :mkdirp yes
;;;###autoload
(defun dan/org-after-todo-statistics-preserve-todo-state (n-done n-not-done)
  "Change KEYWORD state to `DONE` if all subheadings are also `DONE`, otherwise
KEYWORD state is conserved.

N-DONE are the number of subheadings that are done and N-NOT=DONE the number of
headings that are not done. This function is meant to be run as as part of
`org-after-todo-statistics-hook`"
  (let (org-log-done org-log-states)
    (org-todo (if (= n-not-done 0)
                  "DONE"
                (pcase (org-get-todo-state) ;; Keeps the keyword state.
                  ('nil "")
                  (todo todo))))))
#+end_src

Custom function that switches heading from 'TODO' to 'DONE' when all checkboxes are ticked.

#+begin_src elisp :tangle autoload/org.el :mkdirp yes
;;;###autoload
(defun dan/org-checkbox-statistics-change-to-done-when-all-ticked ()
  "Change KEYWORD state to `DONE` if all checkboxes of the heading are ticked.

This function is meant to be run as as part of `org-checkbox-statistics-hook`"
  (let ((todo-state (org-get-todo-state)) beg end)
    (unless (not todo-state)
      (save-excursion
        (org-back-to-heading t)
        (setq beg (point))
        (end-of-line)
        (setq end (point))
        (goto-char beg)
        (if (re-search-forward "\\[\\([0-9]*%\\)\\]\\|\\[\\([0-9]*\\)/\\([0-9]*\\)\\]"
                               end t)
            (if (match-end 1)
                (if (equal (match-string 1) "100%")
                    (unless (string-equal todo-state "DONE")
                      (org-todo 'done))
                  (unless (string-equal todo-state "TODO")
                    (org-todo 'todo)))
              (if (and (> (match-end 2) (match-beginning 2))
                       (equal (match-string 2) (match-string 3)))
                  (unless (string-equal todo-state "DONE")
                    (org-todo 'done))
                (unless (string-equal todo-state "TODO")
                  (org-todo 'todo)))))))))
#+end_src

*** Pretending we are in vim? That's just plain EVIL!

Bad puns aside, vim keybindings are hard to let go once you are used to them.
Luckily, doom comes with much of the heavy lifting already done when it comes to
evil mode. We just gotta customize some minor details.

#+begin_src elisp
(use-package! evil
  :defer t
  :custom
#+end_src

Make horizontal motions move to other lines.

#+begin_src elisp
  (evil-cross-lines t)
#+end_src

Remove highlighted items after search is finished.

#+begin_src elisp
  (evil-ex-search-persistent-highlight nil)
#+end_src

Universal argument mapped to M-u instead.

#+begin_src elisp
  :config
  (map! :g "M-u" #'universal-argument
#+end_src

Remove highlighted items after a search.

#+begin_src elisp
        :m "C-l" #'evil-ex-nohighlight))
#+end_src

*** Line-numbers

This determines the style of line numbers in effect. If set to ~nil~, line
numbers are disabled. For relative line numbers, set this to ~relative~.

#+begin_src elisp
(setq display-line-numbers-type 'relative)
#+end_src

*** Helpful

Let's make an global keybinding to find something I don't understand about emacs
quickly!

#+begin_src elisp
(map! :g "C-c C-d" #'helpful-at-point)
#+end_src

*** Which Key

Doom emacs default config is too slow, lets speed it up.

#+begin_src elisp
(use-package! which-key
  :defer t
  :custom
  (which-key-idle-delay 0.1)
  (which-key-idle-secondary-delay 0.2))
#+end_src

*** Customize Group

An essential interface to know what to customize!

#+begin_src elisp
(use-package! cus-edit
  :defer t
#+end_src

I mostly use it to know the customizable options in a package, chaging the
values within this configuration. So, let's make it show the actual real values.

#+begin_src elisp
  :custom
  (custom-unlispify-menu-entries nil)
  (custom-unlispify-tag-names nil)
  (custom-unlispify-remove-prefixes nil))
#+end_src

*** RSS, or how to get news the old-way.

First, lets bring our feeds into the cloud.

#+begin_src elisp
(use-package! elfeed
  :defer t
  :custom
  (elfeed-db-directory "~/Cloud/elfeed/")
#+end_src

Special faces for special tags.

#+begin_src elisp
  (elfeed-search-face-alist '((unread    elfeed-search-unread-title-face)
                              (star      elfeed-search-unread-count-face)))
#+end_src

Show me entries from within a month that I haven't read and that I have 'starred'.

#+begin_src elisp
  :config
  (setq elfeed-search-filter "@4-week-ago +unread ")
#+end_src

Some entries are worth preserving. By 'starring' them we don't lose them.

#+begin_src elisp
(defalias 'dan/elfeed-search-tag-all-star
         (elfeed-expose #'elfeed-search-tag-all 'star)
         "Add the `star' tag to all selected entries.")

(defalias 'dan/elfeed-search-untag-all-star
         (elfeed-expose #'elfeed-search-untag-all 'star)
         "Remove the `star' tag from all selected entries.")
#+end_src

Expose the aliases to the 'x' keybinding.

#+begin_src elisp
(map! :map 'elfeed-search-mode-map :nv "x" #'dan/elfeed-search-tag-all-star
                                   :nv "X" #'dan/elfeed-search-untag-all-star))
#+end_src

Give it an easy keybinding to access it:

#+begin_src elisp
(map! :leader :desc "RSS feed" :m "o e" #'elfeed)
#+end_src

And point elfeed to the org configuration file.

#+begin_src elisp
(use-package! elfeed-org
  :defer t
  :custom
  (rmh-elfeed-org-files (list (expand-file-name "elfeed.org" org-directory))))
#+end_src

Keybinding to easily find the feeds file.

#+begin_src elisp
(map! :leader
      :desc "RSS feed config" :m "o E" (cmd! (find-file (car rmh-elfeed-org-files))))
#+end_src

*** Mozc (Japanese Input).

I am learning japanese as a hobby, and I do most of my note taking in emacs. To
input japanese text we use google's MOZC.

#+begin_src elisp :tangle packages.el
(package! mozc)
#+end_src

Let's lazy load mozc, so it loads only when our entry function is called.

#+begin_src elisp
(use-package! mozc
  :defer t
#+end_src

The overlay style is sluggish, the echo-area style is pretty and very functional, it even works in the minibuffer!

#+begin_src elisp
  :custom
  (mozc-candidate-style 'echo-area))
#+end_src

Finally, we create a keybinding activate mozc-mode.

#+begin_src elisp
(map! :g "C-x j"  #'dan/toggle-mozc-mode
      :ni "C-x j" #'dan/toggle-mozc-mode)
#+end_src



**** Autoloads

Lexical binding.

#+begin_src elisp :tangle autoload/mozc.el :mkdirp yes
;;; $DOOMDIR/autoload/mozc.el -*- lexical-binding: t; -*-
#+end_src

First, let's define our toggle function and lazily load it. Activates mozc mode
and changes the modeline to show it.

#+begin_src elisp :tangle autoload/mozc.el :mkdirp yes
;;;###autoload
(defun dan/toggle-mozc-mode ()
  "Toggle activation/deactivation of `mozc-mode'."
  (interactive)
  (let* ((active (mozc-mode))
         (msg-modeline (if active
                           '("Activated" . "")
                         '("Deactivated" . ""))))
    (progn
      (message "Mozc Mode %s" (car msg-modeline))
      (setq global-mode-string (cdr msg-modeline))
#+end_src

This part of the function is a bit of hack so mozc plays nicely with Doom's
configuration of evil-org.

#+begin_src elisp :tangle autoload/mozc.el :mkdirp yes
      (map! (:when (and (featurep 'evil-org) evil-org-mode) :map evil-org-mode-map
             (:when mozc-mode    :i "<return>"   nil)
             (:unless mozc-mode  :i "<return>"   (cmd! (org-return electric-indent-mode)))
             (:when mozc-mode    :i "RET"        nil)
             (:unless mozc-mode  :i "RET"        (cmd! (org-return electric-indent-mode))))))))
#+end_src

*** Rust

Seems like rls is more stable than rust-analyzer.

#+begin_src elisp
(use-package! rustic
  :defer t
  :custom
  (rustic-lsp-server 'rls)
#+end_src

When using the rustic popup, be in emacs state.

#+begin_src elisp
  :config
  (when (featurep 'evil)
    (add-hook! 'rustic-popup-mode-hook #'evil-emacs-state)))
#+end_src

*** Web Mode

~web-mode~, as customized in the ~web~ module, has more features that I could
wish for. Indentation is the only sore point I wish to change.

First, text at the beginning of line should not be indented by default.

#+begin_src elisp
(after! web-mode
  (setq web-mode-indent-style 1
#+end_src

The default indentation is of 2 spaces.

#+begin_src elisp
    web-mode-code-indent-offset 2
    web-mode-css-indent-offset 2
    web-mode-markup-indent-offset 2
#+end_src

And no padding!

#+begin_src elisp
    web-mode-part-padding nil
    web-mode-script-padding nil))
#+end_src

*** nvm

=nvm= stands for "n.ode v.ersion m.anager". At it's core it's just a shell
script that keeps versions of node/npm that can be activated on a per-project
basis.  The =nvm.el= package offers a few non-interactive functions to interact
with =nvm=. This functions change the ~PATH~ value inside =emacs=, so when =npm=
or =node= are called from it, they are look in the directory =nvm.el= has set.

#+begin_src elisp :tangle packages.el
(package! nvm)
#+end_src

**** Autoloads

=nvm.el= lacks functions to interactively activate or deactivate a version of
node within emacs.  Luckily, emacs is extensible. We'll create our functions in
a autoloaded file.

#+begin_src elisp :tangle autoload/nvm.el :mkdirp yes
;;; $DOOMDIR/autoload/nvm.el -*- lexical-binding: t; -*-
#+end_src

When loading the autoload file, load the nvm module. Essentially, we give
access to the nvm package to the autoloaded functions.

#+begin_src elisp :tangle autoload/nvm.el :mkdirp yes
(require 'nvm)
#+end_src

A function to deactivate the current version of node, if it was activated by
nvm. Essentially, it removes the modifications nvm may have done to PATH
enviroment variable.

#+begin_src  elisp :tangle autoload/nvm.el :mkdirp yes
;;;###autoload
(defun dan/nvm-deactivate ()
  "Deactivate nvm.

This function will restore the enviroment variable PATH to it's value before nvm
was activated.

If nvm wasn't activated previously, PATH will remain unchanged."
  (interactive)
  (when nvm-current-version
    (let* ((path-re (concat "^" (f-join nvm-dir nvm-runtime-re) nvm-version-re "/bin/?$"))
           (node-version-dir (expand-file-name "bin/" (-last-item nvm-current-version)))
           (new-path-list (--reject (s-matches? path-re it) (parse-colon-path (getenv "PATH")))))
      (setenv "PATH" (s-join path-separator new-path-list))
      (setq nvm-current-version nil)
      (message "NVM deactivated. Restored node version to system default."))))
#+end_src

An ~nvm-use-for~ interactive wrapper. If a .nvmrc can't be found in ~default-directory~, then prompt user.

#+begin_src elisp :tangle autoload/nvm.el :mkdirp yes
;;;###autoload
(defun dan/nvm-use-for ()
  "Activate a node version interactively.

From `default-directory' upwards, a .nvmrc file will be search to fix the nvm version.
If none is found, the user will be prompted to select an available version of node."
  (interactive)
  (condition-case err
      (nvm-use-for)
    ('error
     (let* ((node-system-path "/usr/bin/node")
            (node-system (and (file-exists-p node-system-path)
                              (list (format "System (%s)"
                                            (s-trim (with-temp-buffer
                                                      (call-process-shell-command
                                                       (concat node-system-path " -v") nil t)
                                                      (buffer-string)))))))
            (choice (completing-read "Select a Node version:"
                                     (append (nvm--installed-versions) node-system) nil t)))
       (cond
        ((s-equals-p choice node-system) (dan/nvm-deactivate))
        (t (nvm-use choice)))))))
#+end_src

*** Vue

The language server =VLS= does not analyse the templates of ~.vue~ files by default,
let's change that!

#+begin_src elisp
(after! lsp-vetur
  (setq lsp-vetur-experimental-template-interpolation-service t))
#+end_src

*** Dotenv

Emacs is missing a mode to edit =.env= files. So let's add it one:

#+begin_src elisp :tangle packages.el
(package! dotenv-mode)
#+end_src

Now let's activate it when opening a =.env=:

#+begin_src elisp
(use-package! dotenv-mode
  :mode ("\\.env\\..*\\'" . dotenv-mode))
#+end_src

** Private modules.

=doom= allows the user to [[https://github.com/hlissner/doom-emacs/blob/develop/docs/getting_started.org#writing-your-own-modules][to write their own modules]] in their ~$DOOMDIR~
directory, which will be autoloaded at startup. It offers a few extra features
like interection and extension of ~bin/doom~, a fixed file structure where each
file is loaded at different points of the runtime and other niceties (more
~macros!~).

For now, I haven't had the need to use this feature but is good to be aware of it.
