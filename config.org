# -*- eval: (when (and (fboundp #'+zen/toggle) (not noninteractive)) (+zen/toggle)); -*-

#+TITLE: Dan's DOOM Emacs configuration
#+OPTIONS: tags:nil todo:nil
#+LANGUAGE: en

* Rationale

During my undergraduate years, I remember having trouble setting up a postfix
server for a practical exercise in one of my classes. I had to edit the default
configuration file to harden the security of the system. My server was wrongly
configured, and I couldn't figure out what part of my edits I had messed up. We
had to do all the changes to configuration file through a tty in an FreeBDS
virtual machine, so I had to use a terminal editor. =nano= was my choice
since it was similar to the other GUI editors I had used at the time. After much
frustration, I asked a professor of mine to please help me out. He took over my
seat, closed my =nano= session and reopened the configuration file with a different editor.
He was pressing all sorts of keys on the keyboard at an amazing speed, the
cursor was flying all over the screen. I was simply at awe.

The professor found what was wrong with my configuration and fixed it, telling me what
he had changed. When he left, I tried to look up what command he had run to edit
the file. This was my first experience with... =vim=.  I got introduced to =emacs= some
months later, when I saw a friend of mine taking some notes with it.

In any case, this is the earliest point that I can remember thinking that the
efficiency of text-editing, just like with any other task, is fully dependent on
the tool used to achieve it. Considering that I was on a professional path to
become a software engineer, a job that consists of reading documentation,
source code and editing, I figured that it would pay off in the long run to take
some time to explore what editors were out there and make an educated choice for
a text editor, instead of just using whatever was popular.

** ~(message "Hello, %s!" "emacs")~

Having taken that decision, I played around with =vim= and later on with =emacs=,
finally settling with the former to write the code for my thesis. I started out
with a vanilla configuration, a single =.emacs= file where I would copy and paste
Emacs Lisp from other people's configuration without much thinking.  It was
ugly, messy and buggy, but It was also fun. I loved the idea of using code to
configure the tool that I would use to edit code, so I stuck with it.

My knowledge of Emacs would come from Google searches, blog posts and the online
GNU Emacs documentation. I still hadn't learned how to ask Emacs the things that
I didn't know (The invaluable C-h _).  Embarrassingly, I didn't learn that until
late into my Emacs usage history.  My editing needs were minimal so
even if my configuration didn't have all the bells and whistles of other
editors, It was good enough for me. I also knew, at least on a theoretical
level, that Emacs had almost no limits when it came to extensibility. Emacs can
interact with the OS to do just about anything, which explains part of the
popular saying that refers to Emacs as:

#+begin_quote
A great OS, if only missing a good text editor.
#+end_quote

When I got frustrated with Emacs because I broke it somehow, or I didn't know how
to do something with it, the potential of Emacs as an almost infinitely
extensible editor always kept me from switching editors and moving on. Even now,
is this fact that keeps me going back to it.

** Distro-hopping in Emacs

Life changes and so do our needs. I got my first full-time job as Web Developer
and Emacs had to level up to a robust daily driver. I had to use different
technologies in a project with continuously changing requirements.  My cute
emacs experiment could not keep up. I had to use other IDEs to be able to push
the work-out.  However, I was always missing aspects of Emacs when
using other editors, like the frame, buffer and window model, the automatic
backup files or just the simple fact that I could change almost any aspect of my
emacs if I so desired.

I would still open up Emacs for magit when interacting with git or for org-mode
as my todo app. However, I wanted to use Emacs for more than that. Emacs shines
when you know what you want from it. However, It can be daunting and take a
lot of work to set up a configuration for *general* programming purposes.  Which
packages are good? Which are compatible with what you have? When two or more
packages are similar, how do you decide which one to use? If Emacs was to be my
daily driver, I would have to answer this questions often, which implies
research, time and effort.

_Why work on problems that others have already solved?_ With this in mind, I
decided to try out =spacemacs=, a community developed Emacs distribution full of
pre-configured packages grouped by =layers=. And for a while, It worked out great.
The defaults were good, it was functional enough, and could keep up with the
technologies I was using at work. What was not to love? Well, with continuous
use the wrinkles started to appear. For one, =spacemacs= was slow. It would take a
long time to startup and commands were noticeably sluggish. It was also pretty
buggy.  Sure, the layers for different languages worked reasonably well but from
time to time Emacs would behave in unexpected ways and I would have no idea why.

Looking into ways of making =spacemacs= faster, I stumbled upon =doom= and decided
to try it out. It is fast, at startup and during use. It feels quick and snappy.
Installing =doom= modules was similar enough to configuring =spacemacs= layers.
While =doom= was not by any means buggy, I would get frustrated with its
opinionated defaults.  =doom= would have some keybinding I didn't like, or some
package had some extra behavior different to what I expected, and I wouldn't
know how to change it to what I wanted.

** Back to vanilla.

At this point it was clear to me what was the real problem. My ignorance of the
inner workings of Emacs was my only limiting factor. So I took an extreme
position, I went back to pure vanilla again, discarding all my previous
configurations and starting from scratch, while using other editors for my job.
My objective was to recreate the aspects that I liked from =doom= from scratch in
my own configuration.

I took it slow, researching Emacs thoroughly and little by little building my
configuration, but trying to understand everything that I was changing. I read
[[https://www.masteringemacs.org/][Mickey Peterson's Mastering Emacs]], where I finally learned how to ask Emacs
about the things I don't understand. [[http://ergoemacs.org/][Xah's ergoemacs]] blog was an awesome
reference I keep consulting even now. It has all sorts of information on Emacs lisp
syntax, Emacs concepts and configuration tips and tricks.

Other members of the awesome Emacs community I started follow where [[https://protesilaos.com/dotemacs/][Protesilaos
Stavrou]], a long term =vim= user transformed into a hardcore Emacs user, whose
videos explaining his configuration where a great inspiration for me and taught
me to favor built-in packages over third party packages and most importantly,
how to build my own criteria for what packages I should use.

It took at least two months until I made a configuration that I could use at
work again, but it felt great when I finally managed to have something that was
reasonably fast, reproducible in any computer running Linux and was functional
enough for my use cases that I had made, and I intimately understood!  Although I
am nowhere near an Emacs expert, if such a thing exists, and a lot of details
still escape me. I learned a LOT about not only Emacs, but about lisp,
functional programming and free (as in freedom) extensible software! Going back
to basics paid of in spades.

** Why DOOM?

I'll ask again, _Why work on problems that others have already solved?_. Well, in
my case, It was to learn more about the problem-context.  The thing is, Emacs is
truly immense, even if we don't take into account all the third party packages
written for it. It has its own lisp dialect for extensibility, a =mode= system for
defining unique behavior in each buffer, with =major modes= (one per buffer) and
=minor modes= (can be multiple or none in a buffer) that change the visual
elements, available commands and keybindings, and it has different systems to
detect when and which of these modes it should activate at any given time. It
also has different ways of running system commands synchronously or
asynchronously and processing their output, including a process manager for the
programs that are running under Emacs!

I'm not even being exhaustive. Add to that 40 years of packages and multiple
Emacs releases! This wouldn't be so troublesome if it weren't for the terrible
defaults with which Emacs installs. Ugly default theme and questionable default
bindings aside, it is terribly unoptimized for modern systems slowing down
performance. During my vanilla adventure, a lot of my time was just spent trying
to make Emacs feel more modern and fast, which is time-consuming. It's surprising
that packages such as ~gchm-mode~ and use-package don't come
preinstalled with Emacs as they are incredible time savers, not just with
performance but also in configuration time...

At the beginning of re-configuring my vanilla Emacs, after addressing the
terrible defaults, the problems I was trying to solve were interesting, perhaps
because it was my first time trying to solve them. Things like: What's the best
moment to lazy load this package?, How do I write Spanish accents in Emacs?,
How should I structure my ~*.el~ files directory?. As the configuration grew,
more and more issues started appearing. Nothing major that broke my workflow
but annoyances nonetheless. I would write =FIXME= comments in my ~.el~ files to
keep track of these issues, so I could fix them later.

When I wanted to set up Emacs for a new language environments, I would spend a
lot of time checking out what community packages there were for that specific
environment, putting =TODO= comments with the projects' repository URL, so I could
try out and configure it out later on. Quickly It became the case that for every
=FIXME= or =TODO= comment I would solve, two or three more would appear.

The =FIXME= were not such a big deal, I like hunting bugs and fixing them, since I
always feel like I at least learn something in the process.  The big problem
were the =TODO=, which were not remotely as interesting to solve. Looking for
packages is time-consuming and I would end up not using what I tried out.  Other
times, the packages were so massive I never wanted to because I knew It would
take a long time to really configure it like I wanted to. Honorable mentions in
these categories are =lsp= and =treemacs=.

#+HTML: <p align="center"><img src="https://raw.githubusercontent.com/danilevy1212/doom/master/img/too-many-todos.png"/></p>
#+HTML: <p align="center">Unresolved issues in my vanilla configuration.</p>

So, _Why work on problems that others have already solved?_. Not all problems are
equal, and some problems are just tedious to solve, this is the principal
reason why I choose to go back to =doom=. Another reason is that I strongly agree
with the project guiding principles. =doom= is not and IDE replacement or a
what-you-see-is-what-you-get type of editor. It's fully expected of its users to
customize it and all its functionality is open to the user, so it can be
tinkered with.  No magic, just well-thought-out Emacs lisp macros and hooks!

This is perhaps what I like the most about =doom=, its true power resides in it's
=core= module, where all the macros, functions and hooks used to help the user
extend Emacs resides. The =modules= in =doom= just use those set of tools to offer
configuration options for specific use cases. This offers a mix of the best of
both the worlds of vanilla Emacs and spacemacs. With =doom= I can try out a
module, see what I like, bring it over to my configuration, disable packages
that I don't like and mix them with my own packages in a quick and reliable
manner, much more so that If I were back in vanilla Emacs.

** TL;DR:

[[https://blog.jethro.dev/posts/migrating_to_doom_emacs/][It offers reasonable defaults and lots of functionality without sacrificing extensibility or performance]]

* Installation

** Prerequisites

- Git 2.23+
- Emacs 26.1+ *(27.x is recommended)*
- [[https://github.com/BurntSushi/ripgrep][ripgrep]] 11.0+
- GNU Find
- (Optional) [[https://github.com/sharkdp/fd][fd]] 7.3.0+ (known as ~fd-find~ on Debian, Ubuntu & derivatives) --
  improves performance for many file indexing commands

Additionally, the =doom= executable (located at ~user-emacs-directory/bin/doom~)
can be called with the =doctor= argument to obtain information of possible
missing dependencies used by the modules.

** Steps

First, clone this repository in your ~DOOMDIR~. ~DOOMDIR~ is an environment variable
that points to the location of your private configuration. If ~DOOMDIR~ does not
exist, =doom= will look for your configuration in =doom.d=.

#+begin_src shell :tangle no
export DOOMDIR=/path/to/doom/dir
#+end_src

With the following command you can clone the repository in either case:

#+begin_src shell :tangle no
git clone https://github.com/danilevy1212/doom.git ${DOOMDIR:-~/.doom.d}
#+end_src

Then, just follow the instructions for installing [[https://github.com/hlissner/doom-emacs#install][doom emacs]]. Run ~doom env~, then ~doom tangle~ and finally ~doom install~.

* Configuration

Blocks preceded with =IE= are just examples that are not evaluated, the rest of
the blocks are put in the filename of the corresponding heading.

** init.el

This file controls what Doom modules are enabled and what order they load
in. Remember to run ~doom sync~ after modifying it!

*** Lexical binding.

Emacs lisp by default has dynamic-scope, which is fine if a little weird. However,
dynamic scope comes with a performance penalty. Optional lexical scope has to be
activated with a file parameter, as such:

#+begin_src emacs-lisp :tangle init.el
;;; $DOOMDIR/init.el -*- lexical-binding: t; -*-
#+end_src

This option must be set in each individual file, so it's hardly the last
time we will use these block of code.

*** TODO ~doom!~ modules

The ~doom!~ macro controls which modules are loaded into Emacs. Modules are
package configurations made by the community. In the spirit of Emacs, all the
configuration that comes with a particular module can be extended or even
overwritten by your private configuration.

Modules are open for discovery. Press =SPC h d h= (or =C-h d h= for
non-vim users) to access Doom's documentation. There you'll find a =Module Index=
link where you'll find a comprehensive list of Doom's modules and what
flags they support.

Alternatively, press =gd= (or =C-c c d=) on a module to browse its directory
(for easy access to its source code).

The ~doom!~ macro is capable of some conditional logic, thanks to the ~:if~ and
~:cond~ keywords.  Unfortunately, these keywords are not well documented beyond
and example in the docs. The rest of the keywords match with a directory location.
The symbols following a keyword are a module that reside in said directory.

A module is structurally similar to the ~$DOODIR~ folder. Defines a ~packages.el~ and
~config.el~, plus some extra files that integrates with =autoloads= or =doctor=.  Some
modules come with a ~README.org~ for documentation purposes, others are not, so
it's important to take a look at the source code, see what they define and
configure, before deciding to use a module.

Some modules can be wrapped in a list and given 'flags', that activate extra
optional configuration. The list must have the module name as the head, the flags
as the tail.

**** :input

In the ~japanese~ module only ~pangu spacing~ seems like a package I could use, so I
rather install it standalone.

#+begin_src emacs-lisp :tangle init.el
(doom! :input
       ;;bidi              ; (tfel ot) thgir etirw uoy gnipleh
       ;;chinese
       ;;japanese
       ;;layout            ; auie,ctsrnm is the superior home row
#+end_src

**** :completion

***** Company Mode

In my opinion, this package offers such a boost in productivity it's almost
essential. Sure, the overlay can be distracting for some, but it's
unobtrusive and optional while being a good tool for
discoverability.

#+begin_src emacs-lisp :tangle init.el
       :completion
       (company +childframe)  ; the ultimate code completion backend
#+end_src

Doom offers a bunch of neat little extras. For starters, =+childframe= flag
configures the company overlay to live in its own frame, which looks nicer
in the GUI.

By default, completion starts after a short idle period or with the
=C-SPC= key. While the popup is visible, the following keys are available:

| Keybind | Description                              |
|---------+------------------------------------------|
| =C-n=   | Go to next candidate                     |
| =C-p=   | Go to previous candidate                 |
| =C-j=   | (evil) Go to next candidate              |
| =C-k=   | (evil) Go to previous candidate          |
| =C-h=   | Display documentation (if available)     |
| =C-u=   | Move to previous page of candidates      |
| =C-d=   | Move to next page of candidates          |
| =C-s=   | Filter candidates                        |
| =C-S-s= | Search candidates with helm/ivy          |
| =C-SPC= | Complete common                          |
| =TAB=   | Complete common or select next candidate |
| =S-TAB= | Select previous candidate                |

In the spirit of Vim's omni completion, the following insert mode key binds are
available to evil users to access specific company backend:

| Keybind   | Description                       |
|-----------+-----------------------------------|
| =C-x C-]= | Complete etags                    |
| =C-x C-f= | Complete file path                |
| =C-x C-k= | Complete from dictionary/keyword  |
| =C-x C-l= | Complete full line                |
| =C-x C-o= | Invoke complete-at-point function |
| =C-x C-n= | Complete next symbol at point     |
| =C-x C-p= | Complete previous symbol at point |
| =C-x C-s= | Complete snippet                  |
| =C-x s=   | Complete spelling suggestions     |

Completion candidates are supplied by the functions defined in
~company-backends~. Doom offers a helper macro, ~set-company-backend!~ to change
the value of a ~company-backends~ for a specific major/minor mode locally in the
buffer.  Some examples of how to use it can be found in the
~set-company-backend!~ documentation.

***** vertico

This module is a combination of several modular packages that enhanced =emacs= built-in completion capabilities. This approach is different to those of =ivy= or =helm=, which offer their own separate ecosystem.

#+begin_quote
+ Vertico, which provides the vertical completion user interface
+ Consult, which provides a suite of useful commands using ~completing-read~
+ Embark, which provides a set of minibuffer actions
+ Marginalia, which provides annotations to completion candidates
+ Orderless, which provides better filtering methods
#+end_quote

Some important keybindings.

#+begin_quote
When in an active Vertico completion session, the following doom added
keybindings are available:

| Keybind               | Description                                        |
|-----------------------+----------------------------------------------------|
| =C-p=                 | Go to previous candidate                           |
| =C-n=                 | Go to next candidate                               |
| =C-k=                 | (evil) Go to previous candidate                    |
| =C-j=                 | (evil) Go to next candidate                        |
| =C-;= or =<leader> a= | Open an ~embark-act~ menu to choose a useful action |
| =C-c C-;=             | export the current candidate list to a buffer      |
| =C-SPC=               | Preview the current candidate                      |
| =C-M-k=               | (evil) Go to previous candidate and preview.       |
| =C-M-j=               | (evil) Go to next candidate and preview.           |

~embark-act~ will prompt you with a =which-key= menu with useful commands on the
selected candidate or candidate list, depending on the completion category. Note
that you can press =C-h= instead of choosing a command to filter through the
options with a Vertico buffer, that also has slightly more detailed descriptions
due to Marginalia annotations.
#+end_quote

This module offers a lot unique search commands through the =SPC s= and =SPC f=
prefixes. If the commands come prefixed with the universal command (=SPC u=),
their result with include hidden files.

Marginalia toggle:
#+begin_quote
| Keybind | Description                     |
|---------+---------------------------------|
| =M-A=   | Cycle between annotation levels |
#+end_quote

#+begin_quote
If you want to further configure this module, here are some good places to start:

+ Vertico provides several [[https://github.com/minad/vertico#extensions][extentions]] that can be used to extend it's interface
+ You can add more Marginalia annotation levels and change the existing ones by
  editing ~marginalia-annotator-registry~
+ You can change the available commands in Embark for category ~$cat~ by editing
  ~embark-$cat-map~, and even add new categories. Note that you add categories
  by defining them [[https://github.com/minad/marginalia/#adding-custom-annotators-or-classifiers][through marginalia]], and embark picks up on them.
#+end_quote

#+begin_quote
+ =+icons= Adds icons to =file= and =buffer= category completion selections.
#+end_quote

#+begin_src emacs-lisp :tangle init.el
       (vertico +icons)           ; the search engine of the future
#+end_src

**** :ui

***** That *DOOM* feel.

Most of what makes doom feel like doom is in the =doom=, =doom-dashboard= and =doom-quit=.

#+begin_src emacs-lisp :tangle init.el
       :ui
       ;;deft              ; notational velocity for Emacs
       doom              ; what makes DOOM look the way it does
       doom-dashboard    ; a nifty splash screen for Emacs
       doom-quit         ; DOOM quit-message prompts when you quit Emacs
#+end_src

***** emoji

Not really necessary, but they are fun. Use the ~emojify-insert-emoji~ function
(=SPC i e=) to insert and emoji and ~emojify-apropos-emoji~ to search for them.

#+begin_src emacs-lisp :tangle init.el
       (emoji +unicode)  ; ðŸ™‚
#+end_src

***** hl-todo

=hl-todo= not highlights `TODO` comments in buffers, but also comes some handy
keybindings:

| keybind   | description                      |
|-----------+----------------------------------|
| =]t=      | go to next TODO item             |
| =[t=      | go to previous TODO item         |
| =SPC p t= | show all TODO items in a project |
| =SPC s p= | search project for a string      |
| =SPC s b= | search buffer for string         |


#+begin_src emacs-lisp :tangle init.el
       ;;fill-column       ; a `fill-column' indicator
       hl-todo           ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
#+end_src

***** hydra

The =hydra= module activates a convenient hydras for window controls and text
zoom level.

#+begin_src emacs-lisp :tangle init.el
       hydra
#+end_src

***** indent-guides

Some visual help to quickly understand the indent levels in your code.

#+begin_src emacs-lisp :tangle init.el
       indent-guides     ; highlighted indent columns
#+end_src

***** ligatures

When using ~emacs-major-version >= 28~, enable ligatures, since they can be
composed by =hardfuzz=.

#+begin_src emacs-lisp :tangle init.el
       (:if (>= emacs-major-version 28) ligatures)         ; ligatures and symbols to make your code pretty again
#+end_src

***** Mode line

Doom ain't doom without its mode line.

#+begin_src emacs-lisp :tangle init.el
       ;; minimap           ; show a map of the code on the side
       modeline          ; snazzy, Atom-inspired modeline, plus API
#+end_src

***** nav-flash

To help with getting lost in big buffers, use the =nav-flash= module:

#+begin_src emacs-lisp :tangle init.el
       nav-flash         ; blink cursor line after big motions
#+end_src

***** ophints

This module give a visual hint when selecting or doing operations over text-objects.

#+begin_src emacs-lisp :tangle init.el
       ;;neotree           ; a project drawer, like NERDTree for vim
       ophints           ; highlight the region an operation acts on
#+end_src

***** popup

Using ~display-buffer-alist~ under the hood, =doom= has an emergent window (or
pop-up) management system. It is [[https://github.com/hlissner/doom-emacs/blob/develop/modules/ui/popup/README.org][well documented]], and offers an API to
arbitrarily extend it.

#+begin_src emacs-lisp :tangle init.el
       (popup +defaults)   ; tame sudden yet inevitable temporary windows
       ;;tabs              ; a tab bar for Emacs
       ;; unicode           ; extended unicode support for various languages
#+end_src

***** vc-gutter

This module integrates with git to show hinges on the side of the buffer that
indicate the difference between its contents and the version control version.

#+begin_src emacs-lisp :tangle init.el
       vc-gutter         ; vcs diff in the fringe
#+end_src

***** vi-tilde-fringe

Add a small =~= indicating an empty line, like vi.

#+begin_src emacs-lisp :tangle init.el
       vi-tilde-fringe   ; fringe tildes to mark beyond EOB
#+end_src

***** window select

Configuration for =ace-window= and =winum=. These packages associate windows in the
frame with number, offering a quick and convenient way of selecting a
specific window in the frame.

To use =ace-window= use =C-w C-w=. You can short-cut to the associated window number
using =winum=, with =SPC w {window number}=.

#+begin_src emacs-lisp :tangle init.el
       (window-select +numbers)     ; visually switch windows
#+end_src

***** workspaces

Workspaces is a wrapper over ~persp-mode~. It offers isolated buffers and windows
setups that can be saved into a file a loaded for persistent configurations.
Commands associated with workspaces are under the =SPC TAB= prefix.

It also has a [[https://github.com/hlissner/doom-emacs/tree/develop/modules/ui/workspaces][API]] for programmatic access.

#+begin_src emacs-lisp :tangle init.el
       workspaces        ; tab emulation, persistence & separate workspaces
#+end_src

***** zen

Using ~writeroom-mode~, changes the UI elements of a buffer so its contents
become the main focus. It can be toggled on and off with =SPC t z=.

#+begin_src emacs-lisp :tangle init.el
       zen               ; distraction-free coding or writing
#+end_src

**** :editor

***** evil

I prefer vim's keybindings to Emacs and thankfully, =doom= offers first class
support for ~evil-mode~, a vim emulator inside Emacs, making it easy to get the
benefits of both Emacs and vim.

#+begin_src emacs-lisp :tangle init.el
       :editor
       (evil +everywhere); come to the dark side, we have cookies
#+end_src

Evil is quite complex, and customizing it beyond the default settings can be tricky, as it's finer details are not well documented. Luckily, the community [[https://github.com/noctuid/evil-guide][has covered some of these points]], which make the source code of evil much more bearable.

=doom= comes with emulation for some popular vim plugins:


| Vim Plugin            | Emacs Plugin                   | Keybind(s)                     |
|-----------------------+--------------------------------+--------------------------------|
| vim-commentary        | evil-nerd-commenter            | omap =gc=                        |
| vim-easymotion        | evil-easymotion                | omap =gs=                        |
| vim-lion              | evil-lion                      | omap =gl= / =gL=                   |
| vim-seek or vim-sneak | evil-snipe                     | mmap =s= / =S=, omap =z= / =Z= & =x= / =X= |
| vim-surround          | evil-embrace and evil-surround | vmap =S=, omap =ys=                |

Along with some extra text objects:

+ =a= C-style function arguments (provided by ~evil-args~)
+ =B= any block delimited by braces, parentheses or brackets (provided by
  ~evil-textobj-anyblock~)
+ =c= Comments
+ =f= For functions (but relies on the major mode to have sane definitions for
  ~beginning-of-defun-function~ and ~end-of-defun-function~)
+ =g= The entire buffer
+ =i j k= by indentation (=k= includes one line above; =j= includes one line
  above and below) (provided by ~evil-indent-plus~)
+ =q= For quotes (any kind)
+ =u= For URLs
+ =x= XML attributes (provided by ~exato~)

And custom Ex commands.

| Ex Command          | Description                                                                        |
|---------------------+------------------------------------------------------------------------------------|
| ~:@~                  | Apply macro on selected lines                                                      |
| ~:al[ign][!] REGEXP~  | Align text to the first match of REGEXP. If BANG, align all matches on each line   |
| ~:cp[!] NEWPATH~      | Copy the current file to NEWPATH                                                   |
| ~:dash QUERY~         | Look up QUERY (or the symbol at point) in dash docsets                             |
| ~:dehtml [INPUT]~     | HTML decode selected text / inserts result if INPUT is given                       |
| ~:enhtml [INPUT]~     | HTML encode selected text / inserts result if INPUT is given                       |
| ~:iedit REGEXP~       | Invoke iedit on all matches for REGEXP                                             |
| ~:k[ill]all[!]~       | Kill all buffers (if BANG, affect buffer across workspaces)                        |
| ~:k[ill]b~            | Kill all buried buffers                                                            |
| ~:k[ill]m[!] REGEXP~  | Kill buffers whose name matches REGEXP (if BANG, affect buffers across workspaces) |
| ~:k[ill]o~            | Kill all other buffers besides the selected one                                    |
| ~:k[ill]~             | Kill the current buffer                                                            |
| ~:lo[okup] QUERY~     | Look up QUERY on an online search engine                                           |
| ~:mc REGEXP~          | Invoke multiple cursors on all matches for REGEXP                                  |
| ~:mv[!] NEWPATH~      | Move the current file to NEWPATH                                                   |
| ~:na[rrow]~           | Narrow the buffer to the selection                                                 |
| ~:pad~                | Open a scratch pad for running code quickly                                        |
| ~:ral[ign][!] REGEXP~ | Right-Align text that matches REGEXP. If BANG, align all matches on each line      |
| ~:repl~               | Open a REPL and/or copy the current selection to it                                |
| ~:retab~              | Convert indentation to the default within the selection                            |
| ~:rev[erse]~          | Reverse the selected lines                                                         |
| ~:rm[!] [PATH]~       | Delete the current buffer's file and buffer                                        |
| ~:tcd[!]~             | Send =cd X= to tmux. X = the project root if BANG, X = ~default-directory~ otherwise   |

***** file-templates

Like =yas-snippets=, but for empty files. Includes a mechanism to insert software
licenses as well, through ~M-x +file-templates/insert-license~. The module
documentation gives extra information on customization of the snippets.

#+begin_src emacs-lisp :tangle init.el
       file-templates    ; auto-snippets for empty files
#+end_src

***** fold

#+begin_src emacs-lisp :tangle init.el
       fold              ; (nigh) universal code folding
#+end_src

#+begin_quote
This module marries hideshow, vimish-fold and outline-minor-mode to bring you
marker, indent and syntax-based code folding for as many languages as possible.
#+end_quote

Some keybindings include:

| Keybind | Description               |
|---------+---------------------------|
| =z f=     | Fold region               |
| =z o=     | Unfold region             |
| =z a=     | Toogle fold               |
| =z d=     | Delete folded region      |
| =z m=     | Refold all regions        |
| =z r=     | Unfold all regions        |
| =z E=     | Delete all folded regions |
| =z j=     | Jump to next fold         |
| =z k=     | Jump to previous fold     |

***** format

#+begin_quote
This module integrates code formatters into Emacs.
#+end_quote

For setting my own formatter, there are two options:

- Use the ~set-formatter!~ macro.
- Set the buffer-local variable ~+format-with~ to the name of the formatter to
use. e.g.

#+BEGIN_SRC emacs-lisp :tangle no
(setq-hook! 'python-mode-hook +format-with 'html-tidy)

;; Or set it to `:none' to disable formatting
(setq-hook! 'python-mode-hook +format-with :none)
#+END_SRC

#+begin_quote
Formatters are referred to by the name they were defined with. They can be
looked up in the ~format-all-mode-table~ hash table or in format-all's [[https://github.com/lassik/emacs-format-all-the-code/blob/master/format-all.el#L512][source
code]].
#+end_quote

#+begin_src emacs-lisp :tangle init.el
       format          ; automated prettiness
#+end_src

***** lispy

Lisp aware vim, brought to you by [[https://github.com/noctuid/lispyville][lispyville]]. It brings changes to evil's
movement and text objects in lisps. Only bad thing is that =evil-goggles= doesn't
work with =lispyville='s commands. Bummer.

=lispyville= is automatically activated for:

- Common Lisp
- Emacs Lisp
- Scheme
- Racket
- [[http://docs.hylang.org/en/stable/][Hy]]
- [[http://lfe.io/][LFE]]
- Clojure

#+begin_src emacs-lisp :tangle init.el
       ;;god             ; run Emacs commands without modifier keys
       lispy             ; vim for lisp, for people who don't like vim
#+end_src

***** multiple-cursors

This module adds multiple cursors through two plugins, =evil-mc= and =evil-multiedit=.

#+begin_src emacs-lisp :tangle init.el
       multiple-cursors    ; editing in many places at once
#+end_src

****** evil-multiedit

Keybindings:

| Keybinding | command                              |
|------------+--------------------------------------|
| =M-d=        | evil-multiedit-match-symbol-and-next |
| =M-D=        | evil-multiedit-match-symbol-and-prev |
| =R=          | evil-multiedit-match-all (visual)    |
| =C-M-d=      | evil-multiedit-restore               |

Region active bidings:

| Keybinding | Effect                                                      |
|------------+-------------------------------------------------------------|
| =D=          | Clear region                                                |
| =M-D=        | Clear to end-of-region and go to insert mode                |
| =A=          | Go into insert mode at end-of-region                        |
| =I=          | Go into insert mode at start-of-region                      |
| =V=          | Select the region                                           |
| =P=          | Replace the iedit region with the contents of the clipboard |
| =$=          | Go to end-of-region                                         |
| =0= / ~^~      | Go to start-of-region                                       |
| =gg= / =G=     | Go to the first/last region                                 |

****** evil-mc

Keybindings

| Keybinding | command                                              |
|------------+------------------------------------------------------|
| =gzd=        | evil-mc-make-and-goto-next-match                     |
| =gzD=        | evil-mc-make-and-goto-prev-match                     |
| =gzj=        | evil-mc-make-cursor-move-next-line                   |
| =gzk=        | evil-mc-make-cursor-move-prev-line                   |
| =gzm=        | evil-mc-make-all-cursors                             |
| =gzn=        | evil-mc-make-and-goto-next-cursor                    |
| =gzN=        | evil-mc-make-and-goto-last-cursor                    |
| =gzp=        | evil-mc-make-and-goto-prev-cursor                    |
| =gzP=        | evil-mc-make-and-goto-first-cursor                   |
| =gzq=        | evil-mc-undo-all-cursors                             |
| =gzs=        | evil-mc-skip-and-goto-next-match                     |
| =gzS=        | evil-mc-skip-and-goto-prev-match                     |
| =gzc=        | evil-mc-skip-and-goto-next-cursor                    |
| =gzC=        | evil-mc-skip-and-goto-prev-cursor                    |
| =gzt=        | +multiple-cursors/evil-mc-toggle-cursors             |
| =gzu=        | +multiple-cursors/evil-mc-undo-cursor                |
| =gzz=        | +multiple-cursors/evil-mc-toggle-cursor-here         |
| =gzI=        | evil-mc-make-cursor-in-visual-selection-beg (visual) |
| =gzA=        | evil-mc-make-cursor-in-visual-selection-end (visual) |

***** parinfer

#+begin_quote
Parinfer is a proof-of-concept editor mode for Lisp programming languages. It
will infer some changes to keep Parens and Indentation inline with one another.

https://raw.githubusercontent.com/DogLooksGood/parinfer/a7c041454e05ec2b88333a73e72debaa671ed596/images/demo.gif
#+end_quote

Basically, it's a another editing helper package for lisp, in particular:

- Emacs Lisp
- Clojure
- Scheme
- Lisp
- Racket
- Hy

#+begin_src emacs-lisp :tangle init.el
       ;;objed               ; text object editing for the innocent
       (:if IS-LINUX parinfer) ; turn lisp into python, sort of
#+end_src

***** snippets

#+begin_quote
This module adds snippets to Emacs, powered by yasnippet.
#+end_quote

#+begin_src emacs-lisp :tangle init.el
       ;;rotate-text     ; cycle region at point between text candidates
       snippets          ; my elves. They type so I don't have to
#+end_src

***** word-wrap

#+begin_quote
This module adds a minor-mode ~+word-wrap-mode~, which intelligently wraps long
lines in the buffer without modifying the buffer content.
#+end_quote

#+begin_src emacs-lisp :tangle init.el
       word-wrap         ; soft wrapping with language-aware indent
#+end_src

**** :emacs

***** editor

#+begin_src emacs-lisp :tangle init.el
       :emacs
       (dired +icons)    ; making dired pretty [functional]
#+end_src

=dired-mode=, as configured in the =dired= module, has only a few extra bells and
whistles added. Apart from aesthetic stuff, there are some extra keybindings:

| Keybind | Description                |
|---------+----------------------------|
| =SPC f d= | Find directory with dired  |
| =q=       | Exit dired buffer          |
| =C-c C-r= | Run =dired-rsync=            |
| =C-c C-e= | Rename entries with =wdired= |

This complement the [[https://www.gnu.org/software/emacs/refcards/pdf/dired-ref.pdf][default keybindings]].

***** electric

Built-in automated indentation.

#+begin_src emacs-lisp :tangle init.el
       electric          ; smarter, keyword-based electric-indent
#+end_src

***** ibuffer

Project-aware buffer management.  Similar to =dired=, but for buffers.
Toggled on by the ~SPC b i~ keybinding.

#+begin_src emacs-lisp :tangle init.el
       (ibuffer +icons)  ; interactive buffer management
       ;; undo           ; persistent, smarter undo for your inevitable mistakes
#+end_src

***** undo

#+begin_quote
This module augments Emacs' built-in undo system to be more intuitive and to
persist across Emacs sessions.
#+end_quote

#+begin_src emacs-lisp :tangle init.el
       undo           ; persistent, smarter undo for your inevitable mistakes
#+end_src

***** vc

#+begin_quote
This module augments Emacs built-in version control support and provides better integration with git
#+end_quote

It offers different modes for ~.git{ignore,info,attributes,config} files, a way
to easily visit the remote file of a repo, ~M-x browse-at-remote~, bind to ~SPC g o o~.

#+begin_src emacs-lisp :tangle init.el
       vc                ; version-control and Emacs, sitting in a tree
#+end_src

**** :term

***** eshell

An =emacs= alternative to the traditional shell. From this shell, you have access to all of Emacs internal functions and variables. The features of the =eshell= are too many to [[https://www.gnu.org/software/emacs/manual/html_mono/eshell.html][explain here]].

#+begin_src emacs-lisp :tangle init.el
       :term
       eshell            ; the elisp shell that works everywhere
#+end_src

***** term

A =emacs-lisp= terminal emulator, worse than =vterm=, but gets the job done.

#+begin_src emacs-lisp :tangle init.el
       ;;shell             ; simple shell REPL for Emacs
       (:if IS-MAC term)   ; basic terminal emulator for Emacs
#+end_src

***** vterm

A traditional terminal emulator, powered by [[https://github.com/neovim/libvterm][libvterm]] and Emacs [[https://phst.eu/emacs-modules.html][c modules]].

#+begin_src emacs-lisp :tangle init.el
       (:if IS-LINUX vterm)               ; the best terminal emulation in Emacs
#+end_src

**** :checkers

***** syntax

Setup [[https://www.flycheck.org/en/latest/][flycheck]], the unofficial general programming language checker of Emacs.

#+begin_src emacs-lisp :tangle init.el
       :checkers
       (syntax +childframe) ; tasing you for every semicolon you forget
#+end_src

***** spell

Don't misspell, ever again!

#+begin_src emacs-lisp :tangle init.el
       (spell +aspell +everywhere)             ; tasing you for misspelling mispelling
#+end_src

***** grammar

#+begin_quote
This module adds grammar checking to Emacs to aid your writing by combining
=lang-tool= and =writegood-mode=.
#+end_quote

My english is not the best, neither is my spanish or my æ—¥æœ¬èªž for that matter. Maybe this module can help!

#+begin_src emacs-lisp :tangle init.el
       grammar           ; tasing grammar mistake every you make
#+end_src

**** :tools

***** debugger

Fixing that code, on step at a time.

#+begin_src emacs-lisp :tangle init.el
       :tools
       ;;ansible
       ;;biblio                 ; Writes a PhD for you (citation needed)
       (debugger +lsp)          ; FIXME stepping through code, to help you add bugs
#+end_src

***** direnv

#+begin_quote
This module integrates direnv into Emacs.
#+end_quote

#+begin_src emacs-lisp :tangle init.el
       direnv
#+end_src

***** docker

#+begin_quote
This module allows you to manipulate Docker images, containers & more from
Emacs.

Provides a major =dockerfile-mode= to edit =Dockerfiles=. Additional
convenience functions allow images to be built easily.

=docker-tramp.el= offers a [[https://www.gnu.org/software/tramp/][TRAMP]] method for Docker containers.
#+end_quote

#+begin_src emacs-lisp :tangle init.el
       (docker +lsp)
#+end_src

***** editorconfig

#+begin_quote
This module integrates [[https://editorconfig.org/][EditorConfig]] into Emacs, allowing users to dictate code
style on a per-project basis with an =.editorconfig= file ([[https://editorconfig-specification.readthedocs.io/][formal
specification]]).
#+end_quote

#+begin_src emacs-lisp :tangle init.el
       editorconfig        ; let someone else argue about tabs vs spaces
       ;;ein               ; tame Jupyter notebooks with emacs
#+end_src

***** eval

#+begin_quote
This modules adds inline code evaluation support to Emacs and a universal
interface for opening and interacting with REPLs.
#+end_quote

Most important features.

1. Inline code evaluation.

    #+begin_quote
Quickrun can be invoked via:
+ ~M-x +eval/buffer~ (or ~gR~, or ~M-r~)
+ ~M-x +eval/region~
+ ~M-x +eval/region-and-replace~
+ Evil users can use the ~gr~ operator to select and run a region.
    #+end_quote

    Evaluation handlers can be set with ~set-eval-handler!~ function.

2. REPLs

    #+begin_src
Invoked via:
+ =SPC o r= or ~:repl~ will open a REPL in a popup window. =SPC o R= or ~:repl!~
  will open a REPL in the current window. If a REPL is already open and a
  selection is active, it will be sent to the REPL.
+ ~M-x +eval/open-repl-other-window~ (=SPC o r=)
+ ~M-x +eval/open-repl-same-window~ (=SPC o R=)
+ ~M-x +eval/send-region-to-repl~ (=SPC c s=) while a selection (and REPL) is
  active
    #+end_src

    ~REPLs~ can be registered with ~set-repl-handler!~ function.

More about it's features can be learned in [[doom-modules:tools/eval/README.org][here]].

#+begin_src emacs-lisp :tangle init.el
       (eval +overlay)     ; run code, run (also, repls)
       ;;gist              ; interacting with github gists
#+end_src

***** lookup

#+begin_quote
This module adds code navigation and documentation lookup tools to help you
quickly look up definitions, references, documentation, dictionary definitions
or synonyms.

+ Jump-to-definition and find-references implementations that just work.
+ Powerful xref integration for languages that support it.
+ Search online providers like devdocs.io, stackoverflow, google, duckduckgo or
  youtube (duckduckgo and google have live suggestions).
+ Integration with Dash.app docsets.
+ Support for online (and offline) dictionaries and thesauruses.
#+end_quote

#+begin_src emacs-lisp :tangle init.el
       (lookup +docsets +dictionary +offline)              ; navigate your code and its documentation
#+end_src

***** lsp

#+begin_quote
The Language Server protocol is used between a tool (the client) and a language smartness provider (the server) to integrate features like auto complete, go to definition, find all references and alike into the tool.
#+end_quote

#+begin_src emacs-lisp :tangle init.el
       (lsp +peek)
#+end_src

***** magit

The best porcelain for ~git~, in =emacs=!

#+begin_src emacs-lisp :tangle init.el
       magit             ; a git porcelain for Emacs
       ;;make              ; run make tasks from Emacs
       ;;pass              ; password manager for nerds
#+end_src

***** pdf

#+begin_quote
This module improves support for reading and interacting with PDF files in Emacs.

It uses =pdf-tools=, which is a replacement for the built-in ~doc-view-mode~ for
PDF files. The key difference being pages are not pre-rendered, but instead
rendered on-demand and stored in memory; a much faster approach, especially for
larger PDFs.
#+end_quote

#+begin_src emacs-lisp :tangle init.el
       (:if IS-LINUX pdf)  ; pdf enhancements
       ;;prodigy           ; FIXME managing external services & code builders
       ;;rgb               ; creating color strings
       ;;taskrunner        ; taskrunner for all your projects
       ;;terraform         ; infrastructure as code
       ;;tmux              ; an API for interacting with tmux
#+end_src

***** tree-sitter

#+begin_quote
Tree-sitter is a general programming language parser that efficiently builds and updates Abstract Syntax Trees (AST) for your code. Basically, it can read programming languages and understand the structure and meaning of code without having to execute it. Among many amazing things, one of its best and simplest features to take advantage of is richer syntax highlighting.

    --- https://hungyi.net/posts/use-emacs-tree-sitter-doom-emacs/
#+end_quote

Additionally, this module adds new text objects for =evil-mode=:

| key | text object         |
|-----+---------------------|
| =A=   | parameter list      |
| =f=   | function definition |
| =F=   | function call       |
| =C=   | class               |
| =c=   | comment             |
| =v=   | conditional         |
| =l=   | loop                |

You can jump directly to any of this nodes with the =[g= and =]g= motion commands.

#+begin_src emacs-lisp :tangle init.el
       tree-sitter       ; syntax and parsing, sitting in a tree.. .
       ;;upload            ; map local to remote projects via ssh/ftp
#+end_src

**** :os

***** macos

I use a macbook for work, so this module adds some niceties.

#+begin_src emacs-lisp :tangle init.el
       :os
       (:if IS-MAC macos)  ; improve compatibility with macOS
#+end_src

***** tty

Better integration of Emacs with the terminal emulator, particularly:

#+begin_quote
+ System clipboard integration (through an external clipboard program or OSC-52
  escape codes in supported terminals).
+ Fixes cursor-shape changing across evil states in terminal that support it.
+ Mouse support in the terminal.

#+end_quote

#+begin_src emacs-lisp :tangle init.el
       tty               ; improve the terminal Emacs experience
#+end_src

**** TODO :lang

***** data

Occasionally I will have to edit ~.csv~ files manually. The =data= module comes in handy for this task.

#+begin_src emacs-lisp :tangle init.el
       :lang
       ;;agda              ; types of types of types of types...
       ;;beancount
       ;;cc                ; C/C++/Obj-C madness
       ;;(clojure +lsp)      ; java with a lisp
       ;;common-lisp       ; if you've seen one lisp, you've seen them all
       ;;coq               ; proofs-as-programs
       ;;crystal           ; ruby at the speed of c
       ;;csharp            ; unity, .NET, and mono shenanigans
       data                ; config/data formats
#+end_src

***** emacs-lisp

#+begin_quote
This module extends support for Emacs Lisp in Doom Emacs.

+ Macro expansion
+ Go-to-definitions or references functionality
#+end_quote

#+begin_src emacs-lisp :tangle init.el
       ;;(dart +flutter)   ; paint ui and not much else
       ;;dhall
       ;;elixir            ; erlang done right
       ;;elm               ; care for a cup of TEA?
       emacs-lisp          ; drown in parentheses
       ;;erlang            ; an elegant language for a more civilized age
       ;;ess               ; Emacs speaks statistics
       ;;faust             ; dsp, but you get to keep your soul
       ;;fortran           ; in FORTRAN, GOD is REAL (unless declared INTEGER)
       ;;fsharp            ; ML stands for Microsoft's Language
       ;;fstar             ; (dependent) types and (monadic) effects and Z3
       ;;gdscript          ; the language you waited for
#+end_src

***** golang

#+begin_quote
This module adds [[https://golang.org][Go]] support, with optional (but recommended) LSP support via
[[https://github.com/golang/tools/blob/master/gopls/README.md][gopls]].

+ Code completion (~gocode~)
+ Documentation lookup (~godoc~)
+ Eldoc support (~go-eldoc~)
+ REPL (~gore~)
+ Syntax-checking (~flycheck~)
+ Auto-formatting on save (~gofmt~) (requires =:editor (format +onsave)=)
+ Code navigation & refactoring (~go-guru~)
+ [[../../editor/file-templates/templates/go-mode][File templates]]
+ [[https://github.com/hlissner/doom-snippets/tree/master/go-mode][Snippets]]
+ Generate testing code (~go-gen-test~)
+ Code checking (~flycheck-golangci-lint~)
#+end_quote

#+begin_src emacs-lisp :tangle init.el
       (go +lsp +tree-sitter)           ; the hipster dialect
       ;;(graphql +lsp)    ; Give queries a REST
       ;;(haskell +lsp)      ; a language that's lazier than I am
       ;;hy                ; readability of scheme w/ speed of python
       ;;idris             ;
#+end_src

***** TODO json

#+begin_src emacs-lisp :tangle init.el
       (json +lsp +tree-sitter)              ; At least it ain't XML
       ;;(java +lsp) ; the poster child for carpal tunnel syndrome
#+end_src

***** TODO javascript

#+begin_src emacs-lisp :tangle init.el
       (javascript +lsp +tree-sitter)          ; all(hope(abandon(ye(who(enter(here)))))
       ;;julia             ; a better, faster MATLAB
       ;;kotlin            ; a better, slicker Java(Script)
#+end_src

***** TODO latex

#+begin_src emacs-lisp :tangle init.el
       (latex +lsp)               ; writing papers in Emacs has never been so fun
       ;;lean
       ;;factor
       ;;ledger            ; an accounting system in Emacs
       ;;(lua +lsp +fennel)  ; one-based indices? one-based indices
#+end_src

***** TODO markdown

#+begin_src emacs-lisp :tangle init.el
       markdown          ; writing docs for people to ignore
#+end_src

***** TODO nix

#+begin_src emacs-lisp :tangle init.el
       ;;nim               ; python + lisp at the speed of c
       (nix +tree-sitter)               ; I hereby declare "nix geht mehr!"
       ;;ocaml             ; an objective camel
#+end_src

***** TODO org

#+begin_src emacs-lisp :tangle init.el
       (org +dragndrop +pretty)               ; organize your plain life in plain text
#+end_src

***** TODO python

#+begin_src emacs-lisp :tangle init.el
       ;;php               ; perl's insecure younger brother
       ;;plantuml          ; diagrams for confusing people more
       ;;purescript        ; javascript, but functional
       (python +lsp +pyright +poetry +tree-sitter) ; beautiful is better than ugly
       ;;qt                ; the 'cutest' gui framework ever
       ;;racket            ; a DSL for DSLs
       ;;raku              ; the artist formerly known as perl6
#+end_src

***** TODO rest

#+begin_src emacs-lisp :tangle init.el
       rest                ; Emacs as a REST client
       ;;rst               ; ReST in peace
       ;;(ruby +rails)     ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
#+end_src

***** rust

Rustic mode is great and the integrates really well with cargo. The defaults are
reasonable and with the =+lsp= it integrates nicely with ~lsp-mode~, what's not to
love?

#+begin_src emacs-lisp :tangle init.el
       (rust +lsp +tree-sitter)         ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
#+end_src

***** TODO sh

#+begin_src emacs-lisp :tangle init.el
       ;;scala             ; java, but good
       ;;scheme            ; a fully conniving family of lisps
       (sh +tree-sitter)                  ; she sells {ba,z,fi}sh shells on the C xor
       ;;sml
#+end_src

***** solidity

Emacs has support for any buzzword you can imagine, even =blockchain technologies=.

#+begin_src emacs-lisp :tangle init.el
       solidity          ; do you need a blockchain? No.
       ;;swift             ; who asked for emoji variables?
       ;;terra             ; Earth and Moon in alignment for performance.
       ;;(web +lsp)          ; the tubes
#+end_src

***** TODO yaml

#+begin_src emacs-lisp :tangle init.el
       (yaml +lsp)         ; JSON, but readable
#+end_src

**** TODO :email

#+begin_src emacs-lisp :tangle init.el
       :email
       ;;(mu4e +org +gmail)
       ;;notmuch
       ;;(wanderlust +gmail)
#+end_src

**** TODO :app

***** calendar

#+begin_quote
This module adds a calendar view for Emacs, with org and google calendar sync
support.
#+end_quote

#+begin_src emacs-lisp :tangle init.el
       :app
       calendar
#+end_src

***** TODO everywhere

#+begin_src emacs-lisp :tangle init.el
       ;;emms
       everywhere        ; *leave* Emacs!? You must be joking
#+end_src

***** TODO rss

#+begin_src emacs-lisp :tangle init.el
       ;;irc               ; how neckbeards socialize
       (rss +org)        ; Emacs as an RSS reader
       ;;twitter           ; twitter client https://twitter.com/vnought
#+end_src

**** :config

***** literate

The meat and potatoes of this configuration. This module [[https://orgmode.org/manual/Extracting-Source-Code.html][tangles]] the source code blocks in ~$DOOMDIR/config.org~.

#+begin_src emacs-lisp :tangle init.el
       :config
       literate
#+end_src

***** Better Defaults

#+begin_quote
This module provides a set of reasonable defaults, including:

+ A Spacemacs-esque keybinding scheme
+ Extra Ex commands for evil-mode users
+ A yasnippet snippets library tailored to Doom emacs
+ A configuration for (almost) universally repeating searches with =;= and =,=
#+end_quote

Alongside the reasonable defaults, this module offers tons of convenience commands, under the ~+default/~ prefix.

#+begin_src emacs-lisp :tangle init.el
       (default +bindings +smartparens))
#+end_src

** packages.el

*** How does packages.el work?

To install a package with Doom you must declare them here and run ~doom sync~
on the command line, then restart Emacs for the changes to take effect -- or
use ~M-x doom/reload~.

To install SOME-PACKAGE from MELPA, ELPA or emacsmirror:

ie:
#+begin_src emacs-lisp :tangle no
(package! some-package)
#+end_src

To install a package directly from a remote git repo, you must specify a
~:recipe~. You'll find documentation on what ~:recipe~ accepts here:
https://github.com/raxod502/straight.el#the-recipe-format

ie:
#+begin_src emacs-lisp :tangle no
(package! another-package
  :recipe (:host github :repo "username/repo"))
#+end_src

If the package you are trying to install does not contain a =PACKAGENAME.el=
file, or is located in a sub-directory of the repository, you'll need to specify
~:files~ in the ~:recipe~:

ie:
#+begin_src emacs-lisp :tangle no
(package! this-package
  :recipe (:host github :repo "username/repo"
           :files ("some-file.el" "src/lisp/*.el")))
#+end_src

If you'd like to disable a package included with Doom, you can do so here
with the ~:disable~ property:

ie:
#+begin_src emacs-lisp :tangle no
(package! builtin-package :disable t)
#+end_src

You can override the recipe of a built-in package without having to specify
all the properties for ~:recipe~. These will inherit the rest of its recipe
from Doom or MELPA/ELPA/Emacsmirror:

ie:
#+begin_src emacs-lisp :tangle no
(package! builtin-package :disable t)
#+end_src

You can override the recipe of a built in package without having to specify
all the properties for ~:recipe~. These will inherit the rest of its recipe
from Doom or MELPA/ELPA/Emacsmirror:

ie:
#+begin_src emacs-lisp :tangle no
(package! builtin-package :recipe (:nonrecursive t))
(package! builtin-package-2 :recipe (:repo "myfork/package"))
#+end_src

Specify a ~:branch~ to install a package from a particular branch or tag.
This is required for some packages whose default branch isn't ~master~ (which
our package manager can't deal with; see raxod502/straight.el#279)

ie:
#+begin_src emacs-lisp :tangle no
(package! builtin-package :recipe (:branch "develop"))
#+end_src

Use ~:pin~ to specify a particular commit to install.
ie:
#+begin_src emacs-lisp :tangle no
(package! builtin-package :pin "1a2b3c4d5e")
#+end_src

Doom's packages are pinned to a specific commit and updated from release to
release. The ~unpin!~ macro allows you to unpin single packages...

ie:
#+begin_src emacs-lisp :tangle no
(unpin! pinned-package)
; ...or multiple packages
(unpin! pinned-package another-pinned-package)
; ...Or *all* packages (NOT RECOMMENDED; will likely break things)
(unpin! t)
#+end_src

*** Declarations

For convenience, packages are declared in code blocks close to their
configuration code blocks. Package declaration blocks actually go to into
=packages.el=.  Package declarations blocks can be distinguished for only
containing the ~package!~ macro.

We don't permit the ~package.el~ file to be byte compiled and declare its
lexical binding.

#+begin_src emacs-lisp :tangle packages.el
;; -*- no-byte-compile: t; lexical-binding:t; -*-
;;; $DOOMDIR/packages.el
#+end_src

** Auto-load folder

Auto-loads blocks go into different files in the =autoload= folder.  In this folder
there are files which define functions that and values that whose evaluation is
the entry point into loading other packages. This permits packages to be loaded
exactly when they are needed.

This is all made possible thanks to the auto-load cookie: ~;;;###autoload~.
Placing this on top of a lisp form will do one of two things:

1. Add a ~autoload~ call to Doom's auto-load file (found in
   =~/.emacs.d/.local/autoloads.el=, which is read very early in the startup
   process).
2. Or copy that lisp form to Doom's auto-load file verbatim (usually the case for
   anything other than ~def*~ forms, like ~defun~ or ~defmacro~).

Doom's auto-load file is generated by scanning these files when you execute ~doom
sync~.

As with package declarations blocks, auto-load code blocks will be placed close
to their related configuration blocks. These will be placed in an auto-load
subheading within the corresponding package heading.

** config.el

Most of the configuration actually takes place here. In =config.el= we further
customize the packages from the different modules and in =packages.el=. In other
words, the real fun starts here.  As always, we start by declaring the lexical
binding:

#+BEGIN_SRC emacs-lisp :tangle yes
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-
#+END_SRC

*** ~after-save-hook~ to make scripts executable.

Here's a simple trick to make =she-banged= scripts executable auto-magically by default.

#+begin_src emacs-lisp :tangle yes
(add-hook! 'after-save-hook
           #'executable-make-buffer-file-executable-if-script-p)
#+end_src

*** alert.el

#+begin_quote
Alert is a Growl-workalike for Emacs which uses a common notification interface and multiple, selectable "styles", whose use is fully customizable by the user.
#+end_quote

#+begin_src emacs-lisp :tangle packages.el
(package! alert)
#+end_src

I'm a =linux= user, so we pick the ~libnotify~ for getting system notifications.

#+begin_src emacs-lisp :tangle yes
(use-package! alert
  :defer t
  :custom
  (alert-default-style #'libnotify))
#+end_src

*** annotate.el

#+begin_quote
This package provides a minor mode annotate-mode, which can add annotations to arbitrary files without changing the files themselves. This is very useful for code reviews.
#+end_quote

#+begin_src emacs-lisp :tangle packages.el
(package! annotate)
#+end_src

Activate =annotate-mode= in file buffers that have annotations.

#+begin_src emacs-lisp :tangle yes
(use-package! annotate
  :commands (annotate-load-annotation-data))

(add-hook! find-file
           (let ((file-name (buffer-file-name))
                 (annotation-files (mapcar #'car (annotate-load-annotation-data t))))
             (when (and file-name
                        (member file-name annotation-files))
               (annotate-mode +1))))
#+end_src

#+begin_quote
The current database for annotations is contained in the file indicated by the variable annotate-file.
#+end_quote

#+begin_src emacs-lisp :tangle yes
(after! annotate
  (setq annotate-file (expand-file-name "annotate" doom-cache-dir)))
#+end_src

Blacklist =org-mode=

#+begin_src emacs-lisp :tangle yes
(setq annotate-blacklist-major-mode '(org-mode))
#+end_src

Add keybindings.

#+begin_src emacs-lisp :tangle yes
(after! annotate
  (setq annotate-mode-map (make-sparse-keymap))
  (map! :map annotate-mode-map
        :leader
        :prefix ("b a" . "annotate")
        "a" #'annotate-annotate
        "d" #'annotate-delete-annotation
        "s" #'annotate-show-annotation-summary
        "]" #'annotate-goto-next-annotation
        "[" #'annotate-goto-previous-annotation))
#+end_src

*** awesome-client

A hidden feature of the =eval= module is that any function whose name matches
with the regex ~^\\(?:\\+\\)?\\([^/]+\\)/open-\\(?:\\(.+\\)-\\)?repl$~, will appear as an option in the ~+eval-open-repl~.

With this, we can create a =repl= for the =awesome-client=.

#+begin_src emacs-lisp :tangle autoload/awesomewm.el :mkdirp yes
;;;###autoload
(defun +lua/open-awesome-client-repl ()
   (interactive)
   (pop-to-buffer (make-comint "repl:awesome-client" "awesome-client" nil)))
#+end_src

*** Browse Url

Some of my RSS feeds offer links to =lbry=, which cannot be open directly with a
browser. The following advice takes care of this edge case.

#+begin_src emacs-lisp :tangle yes
(after! browse-url
  (defadvice! dan/browse-url-encode-url--parse-lbry-url (args)
    "Process a `lbry://' link so it can be opened with `browse-url'."
    :filter-args #'browse-url-xdg-open
    (list
     (replace-regexp-in-string "^lbry:\/\/" "https://odysee.com/" (car args)))))
#+end_src

*** calfw

As part of the ~calendar~ module, we get the excellent ~calfw~ package, which displays a calendar view in the emacs buffer.

Europeans start the week on monday!

#+begin_src emacs-lisp :tangle yes
(after! calfw
  (setq calendar-week-start-day 1)
#+end_src

For the =calendar= view, it's useful to be able to see when a task is scheduled.

#+begin_src emacs-lisp :tangle yes
  (defadvice! dan/org-agenda--show-scheduled-in-calfw (fn &rest args)
    :around #'cfw:org-collect-schedules-period
    (let ((org-agenda-todo-ignore-scheduled nil))
      (apply fn args))))
#+end_src

Finally, we create an entrance point to the calendar view.

#+begin_src emacs-lisp :tangle yes
(map! :leader
      :desc "Calfw" :mv "o a c" #'cfw:open-org-calendar)
#+end_src

Disable ~evil-snipe~ in this mode, since It overrides some of the keybindings.

#+begin_src emacs-lisp :tangle yes
(after! evil-snipe
  (add-to-list 'evil-snipe-disabled-modes 'cfw:calendar-mode))
#+end_src

*** company-mode

Begin giving candidates as soon as something is typed. This can be slow sometimes, so it might be a good idea to change it back to it's default value of ~3~. Also reduce the idle delay so it *feels* more responsive.

#+begin_src emacs-lisp :tangle yes
(after! company
  (setq company-minimum-prefix-length 2
        company-idle-delay 0.05))
#+end_src

*** Compilation

Compilation URLs should be followable.

#+begin_src emacs-lisp :tangle yes
(add-hook! compilation-mode #'goto-address-mode)
#+end_src

*** consult-company

A _consult_ing-read interface for ~company-mode~.

#+begin_src emacs-lisp :tangle packages.el
(package! consult-company)
#+end_src

First, let's ensure the package is only loaded on demand, by creating a ~consult-company~ auto-command.

#+begin_src emacs-lisp :tangle yes
(use-package! consult-company
  :commands consult-company)
#+end_src

This package remaps ~completion-at-point~ to use =consult='s interface. Keybind to =C-S-s=.

#+begin_src emacs-lisp :tangle yes
(after! (company consult)
  (map! :map company-active-map
        "C-S-s" #'consult-company))
#+end_src

*** consult-dir

#+begin_quote
Here is a source that adds directory paths provided by the shell tool Fasd:
#+end_quote

#+begin_src emacs-lisp :tangle yes
(after! consult-dir
 (defun consult-dir--fasd-dirs ()
  "Return list of fasd dirs."
  (split-string (shell-command-to-string "fasd -ld") "\n" t))

 (defvar consult-dir--source-fasd
    `(:name     "Fasd dirs"
        :narrow   ?f
        :category file
        :face     consult-file
        :history  file-name-history
        :enabled  ,(lambda () (executable-find "fasd"))
        :items    ,#'consult-dir--fasd-dirs)
   "Fasd directory source for `consult-dir'.")

 (add-to-list 'consult-dir-sources 'consult-dir--source-fasd t))
#+end_src

*** consult-projectile

#+begin_quote
A package to incorporate projectile into consult. This allows to choose a project, when none is selected or choose a project buffer/file.
#+end_quote

#+begin_src emacs-lisp :tangle packages.el
(package! consult-projectile)
#+end_src

~consult-projectile~ also allows for narrowing in ~emacs >= 28~, making it more useful than the default projectile command in =doom=. Narrow selection with B for buffer, F for file or P for project.

#+begin_src emacs-lisp :tangle yes
(use-package! consult-projectile
  :defer t
  :init
  (map! :leader
        :desc "Project find" "SPC" #'consult-projectile))
#+end_src

Incorporate the same behavior as ~projectile-switch-project~ when changing project:

#+begin_src emacs-lisp :tangle yes
(after! consult-projectile
  (setq consult-projectile-use-projectile-switch-project t))
#+end_src

*** Customize Group

An essential interface to know what to customize!

#+begin_src emacs-lisp :tangle yes
(use-package! cus-edit
  :defer t
#+end_src

I use it to know the customizable options in a package, changing the
values within this configuration. So, let's make it show the actual real values.

#+begin_src emacs-lisp :tangle yes
  :custom
  (custom-unlispify-menu-entries nil)
  (custom-unlispify-tag-names nil)
  (custom-unlispify-remove-prefixes nil))
#+end_src

*** Default font

Doom exposes five (optional) variables for controlling fonts in Doom. Here
are the three important ones:

+ ~doom-font~
+ ~doom-variable-pitch-font~
+ ~doom-big-font~ -- used for ~doom-big-font-mode~; use this for
  presentations or streaming.

They all accept either a font-spec, font string ("Input Mono-12"), or xlfd
font string. You generally only need these two:

ie:
#+begin_src emacs-lisp :tangle no
(setq doom-font (font-spec :family "monospace" :size 12 :weight 'semi-light)
      doom-variable-pitch-font (font-spec :family "sans" :size 13))
#+end_src

Let's _choose_ our *monospaced* font, /Sarasa Mono J/ goodness:

#+begin_src emacs-lisp :tangle yes
(setq doom-font (font-spec :family "Sarasa Mono J" :size 18 :weight 'semi-light))
#+end_src

And our =variable pitch= +font+, ~Sarasa UI J~:

#+begin_src emacs-lisp :tangle no
(setq doom-variable-pitch-font (font-spec :family "Sarasa UI J" :size 18 :weight 'extra-light))
#+end_src

Comments and keywords should pop more...

#+begin_src emacs-lisp :tangle yes
(custom-set-faces!
  '(font-lock-comment-face :slant italic)
  '(font-lock-keyword-face :slant italic))
#+end_src

When in zen mode, scale text just a bit.

#+begin_src emacs-lisp :tangle yes
(after! writeroom-mode
  (setq +zen-text-scale 1.25))
#+end_src

Not everything fits in the =mode-line=, so let's make fonts and icons smaller:

#+begin_src emacs-lisp :tangle yes
(custom-set-faces!
  '(mode-line :height 90 :inherit 'variable-pitch)
  '(mode-line-inactive :height 80 :inherit 'variable-pitch))

(after! all-the-icons
  (setq all-the-icons-scale-factor 1.1))
#+end_src

The filename in the =mode line= occupies way too much space.

#+begin_src emacs-lisp :tangle yes
(after! doom-modeline
  (setq doom-modeline-buffer-file-name-style 'truncate-with-project))
#+end_src

*** Default theme

There are two ways to load a theme. Both assume the theme is installed and
available. You can either set ~doom-theme~ or manually load a theme with the
~load-theme~ function. This is the default:

#+begin_src emacs-lisp :tangle yes
(setq doom-theme 'doom-nord)
#+end_src

**** Nord powered aesthetics.

Let's add some small customization to make everything a bit brighter and bigger:

#+begin_src emacs-lisp :tangle yes
(use-package! doom-nord-theme
  :defer t
  :custom
  (doom-nord-brighter-modeline t)
  (doom-nord-padded-modeline t)
  (doom-nord-region-highlight 'frost))
#+end_src

*** Detached

#+begin_quote
Detached, or Detach Emacs, is a package to run shell commands completely detachedd from Emacs.
#+end_quote

#+begin_src emacs-lisp :tangle packages.el
(package! detached)
#+end_src

#+begin_quote
The detachable nature of the package means that commands started with it can outlive Emacs, which also works on remote hosts, essentially offering a lightweight alternative to Tmux or GNU Screen.
#+end_quote

#+begin_src emacs-lisp :tangle yes
(use-package! detached
  :defer t
  :config
  (setq detached-db-directory doom-cache-dir
        detached-session-directory (temporary-file-directory))
  (detached-init))
#+end_src

~detached-shell-command~ acts as a replacement to ~async-shell-command~.

#+begin_src emacs-lisp :tangle yes
(map! :g "M-&" #'detached-shell-command)
#+end_src

~detached-consult~ allows us to manage the active sessions behind =detached=.

#+begin_src emacs-lisp :tangle yes
(use-package! detached-consult
  :defer t
  :init
  (map! :leader
        :desc "Shell Sessions Detached" :g "o s" #'detached-consult-session))
#+end_src

~embark~ can integrate with ~detached~.

#+begin_src emacs-lisp :tangle yes
(after! (embark detached)
  (defvar embark-detached-map (make-composed-keymap detached-action-map embark-general-map))
  (add-to-list 'embark-keymap-alist '(detached . embark-detached-map)))
#+end_src

The commands ~detached-compile~ and ~detached-compile-recompile~ can act as drop in replacements for ~compile~ and ~compile-recompile~, respectively.

#+begin_src emacs-lisp :tangle yes
(use-package! detached-compile
  :after detached
  :init
  (map! :map detached-compilation-mode-map
        :desc "Detache Session" :g "C-c C-q" #'detached-consult-session
        :leader
        :desc "Compile" :g  "c c" #'detached-compile
        :desc "Recompile" :g "c C" #'detached-compile-recompile))
#+end_src

A small hack to integrate ~detached~ into ~projectile~.

#+begin_src emacs-lisp :tangle yes
(after! projectile
  (defadvice! dan/projectile-run-compilation--use-detached (cmd &optional use-comint-mode)
    :override #'projectile-run-compilation
    (if (functionp cmd)
        (funcall cmd)
      (detached-compile cmd use-comint-mode))))
#+end_src

*** Dired

One thing really missing from the default configuration of =dired= is an easy
way to move up and down from directories.

#+begin_src emacs-lisp :tangle yes
(after! dired
  (map! :map dired-mode-map
        :m "h" #'dired-up-directory
        :m "l" #'dired-find-file)
#+end_src

Most of the information =dired= throws at you is not really necessary, so let's
hide it by default. One can toggle this information on/off with ~(~ keybinding.

#+begin_src emacs-lisp :tangle yes
  (add-hook! dired-mode #'dired-hide-details-mode)
#+end_src

But, do show git information on repositories by default, can be toggled on/off with ~)~.

#+begin_src emacs-lisp :tangle yes
  (add-hook! 'dired-after-readin-hook #'+dired-enable-git-info-h)
#+end_src

There is a class between ~dired-subtree~ and ~dired-git-info~. Luckily, there is a [[https://github.com/clemera/dired-git-info/issues/9][hack]] to fix it.

#+begin_src emacs-lisp :tangle yes
  (defadvice! dan/dired-subtree-toggle-advice (orig-fn &rest args)
    :around #'dired-subtree-toggle
    (cond ((bound-and-true-p dired-git-info-mode)
           (dired-git-info-mode -1)
           (apply orig-fn args)
           (dired-git-info-mode +1))
          (t (apply orig-fn args)))))
#+end_src

Opening files from =dired= with an external program is a bit of drag by default, so
we add the =dired-open= package to take care of that.

#+begin_src emacs-lisp :tangle packages.el
(package! dired-open)
#+end_src

The variable ~dired-open-guess-shell-alist~ determines if the file is opened with
an external program.

#+begin_src emacs-lisp :tangle yes
(use-package! dired-open
  :after dired
  :custom
  (dired-open-functions (list #'dired-open-guess-shell-alist
                              #'dired-open-by-extension
                              #'dired-open-subdir))
  (dired-guess-shell-alist-user '(("\\.\\(?:docx\\|djvu\\|eps\\)\\'" "xdg-open")
                                  ("\\.\\(?:\\|gif\\|xpm\\)\\'" "xdg-open")
                                  ("\\.\\(?:xcf\\)\\'" "xdg-open")
                                  ("\\.csv\\'" "xdg-open")
                                  ("\\.tex\\'" "xdg-open")
                                  ("\\.\\(?:mp4\\|mkv\\|avi\\|flv\\|rm\\|rmvb\\|ogv\\|mov\\)\\(?:\\.part\\)?\\'" "xdg-open")
                                  ("\\.\\(?:mp3\\|flac\\)\\'" "xdg-open")
                                  ("\\.html?\\'" "xdg-open")
                                  ("\\.md\\'" "xdg-open"))))
#+end_src

The following packages reduce the ~dired buffer~ clutter by condensing the information into a single buffer.

#+begin_src emacs-lisp :tangle packages.el
(package! dired-subtree)
(package! dired-collapse)
#+end_src

~dired-collapse~ condenses empty directory paths or file paths with a single file in them. ~dired-subtree~ enables a tree view of te directory, which puts the information of sub-directories contents in the same buffer.

#+begin_src emacs-lisp :tangle yes
(use-package! dired-subtree
  :after dired)

(use-package! dired-collapse
  :hook (dired-mode . dired-collapse-mode))
#+end_src

=dired= can get hung up in some operations. Luckily, =dired-async= can do the same procedures without blocking.

#+begin_src emacs-lisp :tangle yes
(add-hook! dired-mode #'dired-async-mode)
#+end_src

Add keybindings overriding blocking operations.

#+begin_src emacs-lisp :tangle yes
(after! dired
  (map! :map dired-mode-map
        :n "R" #'dired-async-do-rename
        :n "C" #'dired-async-do-copy
        :n "S" #'dired-async-do-symlink
        :n "H" #'dired-async-do-hardlink))
#+end_src

*** Dotenv

Emacs is missing a mode to edit =.env= files. So let's add it one:

#+begin_src emacs-lisp :tangle packages.el
(package! dotenv-mode)
#+end_src

Now let's activate it when opening a =.env=:

#+begin_src emacs-lisp :tangle yes
(use-package! dotenv-mode
  :mode ("\\.env\\.?.*\\'" . dotenv-mode))
#+end_src

*** Elfeed

First, lets bring our feeds into the cloud.

#+begin_src emacs-lisp :tangle yes
(use-package! elfeed
  :defer t
  :custom
  (elfeed-db-directory "~/Cloud/elfeed/")
#+end_src

Special faces for special tags.

#+begin_src emacs-lisp :tangle yes
  (elfeed-search-face-alist '((unread    elfeed-search-unread-title-face)
                              (star      elfeed-search-unread-count-face)))
#+end_src

Show me entries from within a month that I haven't read and that I have 'starred'.

#+begin_src emacs-lisp :tangle yes
  :config
  (setq elfeed-search-filter "@4-week-ago +unread ")
#+end_src

Some entries are worth preserving. By 'starring' them we don't lose them.

#+begin_src emacs-lisp :tangle yes
  (defalias 'dan/elfeed-search-tag-all-star
          (elfeed-expose #'elfeed-search-tag-all 'star)
          "Add the `star' tag to all selected entries.")

  (defalias 'dan/elfeed-search-untag-all-star
          (elfeed-expose #'elfeed-search-untag-all 'star)
          "Remove the `star' tag from all selected entries.")
#+end_src

Expose the aliases to the =x= keybinding.

    #+begin_src emacs-lisp :tangle yes
  (map! :map 'elfeed-search-mode-map
        :nv "x" #'dan/elfeed-search-tag-all-star
        :nv "X" #'dan/elfeed-search-untag-all-star))
#+end_src

Automatically updating feed when opening =elfeed=.

#+begin_src emacs-lisp :tangle yes
(add-hook! 'elfeed-search-mode-hook #'elfeed-update)
#+end_src

When updating the entries, commit changes to the DB.

#+begin_src emacs-lisp :tangle yes
(after! elfeed
  (defadvice! dan/elfeed-search-update--force--commit-changes (&rest _)
    "After updating the elfeed, commit changes to DB."
    :after #'elfeed-search-update--force
    (elfeed-db-save-safe)))
#+end_src

Give it an easy keybinding to access it:

#+begin_src emacs-lisp :tangle yes
(map! :leader :desc "News feed" :m "o n" #'=rss)
#+end_src

*** Elfeed Goodies

#+begin_quote
Various bits and pieces to enhance the Elfeed user experience.
#+end_quote

#+begin_src emacs-lisp :tangle yes
(after! elfeed-goodies
  (setq elfeed-goodies/feed-source-column-width 24
        elfeed-goodies/tag-column-width 40
        elfeed-goodies/entry-pane-position 'bottom))
#+end_src

*** Elfeed Org

And point =elfeed= to the org configuration file.

#+begin_src emacs-lisp :tangle yes
(after! elfeed
  (setq rmh-elfeed-org-files (list (expand-file-name "elfeed.org" org-directory))))
#+end_src

Keybinding to easily find the feeds file.

#+begin_src emacs-lisp :tangle yes
(map! :leader
      :desc "News feed config" :m "o N" (cmd! (unless (featurep 'elfeed-org)
                                                (require 'elfeed-org))
                                              (find-file (car rmh-elfeed-org-files))))
#+end_src

*** Elfeed Tube

#+begin_quote
Elfeed Tube is an Emacs package for a richer, interactive, noise-free and fully text-capable interface to your Youtube subscriptions and playlists using Elfeed, the RSS feed reader for Emacs.
#+end_quote

#+begin_src emacs-lisp :tangle packages.el
(package! elfeed-tube
  :recipe (:host github :repo "karthink/elfeed-tube"))
#+end_src

Simple setup.

#+begin_src emacs-lisp :tangle yes
(use-package elfeed-tube
  :after elfeed
  :custom
  (elfeed-tube-auto-save-p  t)
  (elfeed-tube-auto-fetch-p t)
  :config
  (elfeed-tube-setup))
#+end_src

*** eshell

The keybinding =M-SPC m b= inserts the name of a buffer in the =eshell= syntax.
However, sometimes it's useful to refer to the buffer by its string name
representation. So let's make an extra keybinding for said case:

#+begin_src emacs-lisp :tangle yes
(after! eshell
  (map! :map eshell-mode-map
        (:localleader
         :desc "Insert Symbolic Buffer Name" "B" #'eshell-insert-buffer-name
         :desc "Insert String Buffer Name" "b" #'dan/eshell-insert-buffer-name))
#+end_src

Do not use bash for auto-completion backend.

#+begin_src emacs-lisp :tangle yes
  (setq fish-completion-fallback-on-bash-p nil))
#+end_src

**** Auto-loads

Here I define the slightly modified version of ~eshell-insert-buffer-name~.

#+begin_src emacs-lisp :tangle autoload/eshell.el :mkdirp yes
;;; $DOOMDIR/autoload/eshell.el -*- lexical-binding: t; -*-

;;;###autoload
(defun dan/eshell-insert-buffer-name (buffer-name)
  "Insert BUFFER-NAME into the current buffer at point.

The BUFFER-NAME is given as string surrounded by \"\"."
  (interactive "BName of buffer: ")
  (insert-and-inherit "\"" buffer-name "\""))
#+end_src

*** evil

Vim keybindings are hard to let go once you are used to them.
Luckily, doom comes with much of the heavy lifting already done when it comes to
evil mode. We just gotta customize some minor details.

#+begin_src emacs-lisp :tangle yes
(use-package! evil
  :defer t
  :custom
#+end_src

Make horizontal motions move to other lines.

#+begin_src emacs-lisp :tangle yes
  (evil-cross-lines t)
#+end_src

Remove highlighted items after search is finished.

#+begin_src emacs-lisp :tangle yes
  (evil-ex-search-persistent-highlight nil)
#+end_src

Don't continue commented lines with o/O.

#+begin_src emacs-lisp :tangle yes
  (+evil-want-o/O-to-continue-comments nil)
#+end_src

Don't override the contents of the " register after pasting on a block.

#+begin_src emacs-lisp :tangle yes
  (evil-kill-on-visual-paste nil)
#+end_src

Implicit /g flag on evil ex substitution. Put =g= flag to reverse it.

#+begin_src emacs-lisp :tangle yes
  (evil-ex-substitute-global t)
#+end_src

Yank by actual lines of text and not by screen lines, less confusing.

#+begin_src emacs-lisp :tangle yes
  :init
  (setq evil-respect-visual-line-mode nil)
#+end_src

Universal argument mapped to M-u instead.

#+begin_src emacs-lisp :tangle yes
  :config
  (map! :g "M-u" #'universal-argument
#+end_src

Remove highlighted items after a search.

#+begin_src emacs-lisp :tangle yes
        :m "C-l" #'evil-ex-nohighlight))
#+end_src

Center the cursor after jumping to a new search entry.

#+begin_src emacs-lisp :tangle yes
(after! evil
  (defun dan/center-after-move (&rest _)
    "Center screen after search."
    (evil-scroll-line-to-center nil))

  (dolist (command '(evil-ex-search-next
                     evil-ex-search-previous))
    (advice-add command :after #'dan/center-after-move))

  (after! evil-snipe
    (dolist (command '(evil-snipe-repeat
                       evil-snipe-seek))
      (advice-add command :after #'dan/center-after-move))))
#+end_src

Create =undo= boundaries after certain key presses in =insert-mode=.

#+begin_src emacs-lisp :tangle yes
(after! evil
  (add-hook! 'post-self-insert-hook
    (when (and (evil-insert-state-p)
               (memq (char-before)
                     (seq-concatenate 'list
                                      ;; English and Spanish
                                      '(?. ?, ?! ?\( ?\{ ?\[ ??)
                                      ;; æ—¥æœ¬èªž
                                      '(?ã€‚ ?ã€ ?\ã€Œ ?\ï¼ˆ ?\ï½› ?ãƒ»))))
      (evil-end-undo-step)
      (evil-start-undo-step))))
#+end_src

*** evil-quick-diff

Quickly diff to regions of text.

#+begin_src emacs-lisp :tangle yes
(map! :leader
      :prefix "b"
      "q" #'evil-quick-diff
      "Q" #'evil-quick-diff-cancel)
#+end_src

*** evil-snipe

~evil-snipe~ is a simple but powerful plugin, that adds a =snipe= two character motion, plus the possibility of make builtin motions work further than a single line.

#+begin_src emacs-lisp :tangle yes
(after! evil-snipe
  (setq evil-snipe-scope 'whole-buffer))
#+end_src

*** Harpoon

#+begin_quote
Harpoon plugin for emacs, based on the plugin from ThePrimeagen.

This plugin offers quick bookmarks separated by project and branch. You can quick navigate between your working files and forget about that files opened that you will not use anymore.

Harpoon persists between emacs sessions.
#+end_quote

#+begin_src emacs-lisp :tangle packages.el
(package! harpoon
  :recipe (:host github :repo "otavioschwanck/harpoon.el"))
#+end_src

Define quick access keybindings.

#+begin_src emacs-lisp :tangle yes
(use-package harpoon
  :defer t
  :custom
  (harpoon-separate-by-branch t)
  :init
  (map! :leader
        :prefix ("j" . "harpoon")
        "c" 'harpoon-clear
        "f" 'harpoon-toggle-file
        "a" 'harpoon-add-file
        "m" 'harpoon-toggle-quick-menu
        "1" 'harpoon-go-to-1
        "2" 'harpoon-go-to-2
        "3" 'harpoon-go-to-3
        "4" 'harpoon-go-to-4
        "5" 'harpoon-go-to-5
        "6" 'harpoon-go-to-6
        "7" 'harpoon-go-to-7
        "8" 'harpoon-go-to-8
        "9" 'harpoon-go-to-9))
#+end_src

*** Hippie Expand

An manual completion system, bind to ~M-/~. Useful for expanding in modes that don't have full context, like a ~fundamental-mode~ buffer.

#+begin_src emacs-lisp :tangle yes
(map! :g [remap dabbrev-expand] #'hippie-expand)
#+end_src

*** Hydra

Let's make the =hydra= module's functions easily accessible:

#+begin_src emacs-lisp :tangle yes
(map! :leader
      :desc "Navigate/Hydra"  :m "w N" #'+hydra/window-nav/body
      :desc "Text-Zoom/Hydra" :m "w f" #'+hydra/text-zoom/body)
#+end_src

*** image

Help ~emacs~ interpret exotic image formats using external programs, like ~ffmpeg~.

#+begin_src emacs-lisp :tangle yes
(setq image-use-external-converter t)
#+end_src

*** imenu-list

#+begin_quote
This Emacs minor-mode creates an automatically updated buffer called *Ilist* that is populated with the current buffer's imenu entries. The *Ilist* buffer is typically shown as a sidebar (Emacs vertically splits the window).
#+end_quote

#+begin_src emacs-lisp :tangle packages.el
(package! imenu-list)
#+end_src

Keybindings:

| Command                  | Keybinding | Description                              |
|--------------------------+------------+------------------------------------------|
| ~imenu-list~               | =SPC o i=    | Open/Toggle =Ilist= buffer.                |
| ~imenu-list-go-entry~      | =RET=        | Go to =imenu= entry.                       |
| ~imenu-list-display-entry~ | =d=          | Display the =imenu= entry in other buffer. |
| ~imenu-list-quit-window~   | =q=          | Quit =Ilist= buffer.                       |
| ~hs-toggle-hiding~         | =TAB=        | Toggle fold/unfold =imenu= entry.          |

#+begin_src emacs-lisp :tangle yes
(use-package! imenu-list
  :defer t
  :init
  (map! :leader
        :desc "Index" :g "o i" #'imenu-list-smart-toggle))
#+end_src

Reduce the delay to update the buffer when idle.

#+begin_src emacs-lisp :tangle yes
(setq imenu-list-idle-update-delay 0.2)
#+end_src

Take less screen real-state.

#+begin_src emacs-lisp :tangle yes
(setq imenu-list-size 0.2)
#+end_src

Force size we just defined.

#+begin_src emacs-lisp :tangle yes
(setq imenu-list-auto-resize t)
#+end_src

Recenter window after =jumping= to an entry.

#+begin_src emacs-lisp :tangle yes
(after! imenu-list
 (setq imenu-list-after-jump-hook '(recenter-top-bottom)))
#+end_src

*** indent-guides

Use the bitmap to display the indent level if we are in a graphic interface.

#+begin_src emacs-lisp :tangle yes
(after! highlight-indent-guides
  (setq highlight-indent-guides-method (if (display-graphic-p)
                                           'bitmap
                                         'character)
        highlight-indent-guides-responsive 'top))
#+end_src

*** Language Tool

Do not run the jar file! Run the binary.
#+begin_src emacs-lisp :tangle yes
(setq langtool-bin "languagetool-commandline")
#+end_src

Most of the time, assume I speak English.

#+begin_src emacs-lisp :tangle yes
(setq langtool-mother-tongue "en")
#+end_src

*** Line-numbers

This determines the style of line numbers in effect. If set to ~nil~, line
numbers are disabled. For relative line numbers, set this to ~relative~.

#+begin_src emacs-lisp :tangle yes
(setq display-line-numbers-type 'relative)
#+end_src

*** Lsp

~plists~ provide better performance in deserialization and also put less presure than hash-table.

#+begin_src emacs-lisp :tangle yes
(setq lsp-use-plists "true")
#+end_src

*** Lua

Search for the ~lsp-server~ in path:

#+begin_src emacs-lisp :tangle yes
(after! lsp-lua
   (setq lsp-clients-lua-language-server-command "lua-language-server"))
#+end_src

Add ~lsp-lua-diagnostics-globals~ as a ~safe-local-variable~.

#+begin_src emacs-lisp :tangle yes
(after! lua-mode
  (put 'lsp-lua-diagnostics-globals
       'safe-local-variable
       (lambda (e)
         (and (vectorp e)
              (--all?
               (and (stringp it)
                    (not (string-empty-p it)))
               (seq-concatenate 'list e))))))
#+end_src

Add ~lsp-lua-workspace-library~ as a ~safe-local-variable~.

#+begin_src emacs-lisp :tangle yes
(after! lua-mode
  (put 'lsp-lua-workspace-library 'safe-local-variable
       (lambda (e)
         (let ((is-dir-p (lambda (dir) (and (stringp dir))
                           (file-directory-p dir))))
           (and (listp e)
                (--all? (pcase it
                          (`(,first . ,last) (and (funcall is-dir-p first)
                                                  (or (eq last t)
                                                      (and (listp last)
                                                           (-all? is-dir-p
                                                                  last))))))
                        e))))))
#+end_src

*** magit-delta

This =emacs= package provides a minor mode which configures =magit= to use delta when displaying diffs.

#+begin_src emacs-lisp :tangle packages.el
(package! magit-delta)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! magit-delta
  :custom (magit-delta-default-dark-theme "Nord")
  :hook   (magit-mode . magit-delta-mode))
#+end_src

~magit-delta-mode~ can be slow on big diffs. Luckily, we can [[https://github.com/dandavison/magit-delta/issues/9#issuecomment-795435781][advice the appropiate functions]] to deactivate the mode on big buffers.

#+begin_src emacs-lisp :tangle yes
(after! magit-delta
  (defcustom dan/magit-delta-point-max 50000
    "Maximum length of diff buffer which `magit-delta' will tolerate."
    :group 'magit-delta
    :type  'natnum)
  (defadvice! dan/magit-delta-colorize-maybe (fn &rest args)
    "Disable mode if there are too many characters."
    :around #'magit-delta-call-delta-and-convert-ansi-escape-sequences
    (if (<= (point-max) dan/magit-delta-point-max)
        (apply fn args)
      (magit-delta-mode -1))))
#+end_src

Re-enable mode after ~magit-refresh~ if there aren't too many characters.

#+begin_src emacs-lisp :tangle yes
(after! magit
  (add-hook! 'magit-post-refresh-hook
    (when (and (not magit-delta-mode)
               (<= (point-max) dan/magit-delta-point-max))
      (magit-delta-mode +1))))
#+end_src

*** Man

The default =popup-rule= makes the buffer appear in the lower half of the screen. =man= pages use more vertical space, so we push it to the right side of the frame.

#+begin_src emacs-lisp :tangle yes
(add-transient-hook! 'doom-first-input-hook
           (let ((cell (assoc 'side
                              (assoc "^\\*\\(?:Wo\\)?Man " display-buffer-alist))))
             (setcdr cell 'right)))
#+end_src

*** Modeline

The default =doom-modeline= is great, the only thing is that I want it to show me
the evil state I am in with a letter instead of an icon:

#+begin_src emacs-lisp :tangle yes
(use-package! doom-modeline
  :defer t
  :custom
  (doom-modeline-modal-icon nil))
#+end_src

*** New Lines

Emacs aggressively adds a ~\n~ to files, which is technically a good practice. However, lots of other IDEs don't do this. In collaborative version controlled projects, this can result in emacs stubbornly adding a hunk at the end of the file, which can lead to problems, from strange commits diffs to tests failing because files where not expected to have a trailing new line.

We change it so emacs simply asks us first if we want to add the ~\n~ before saving.

#+begin_src emacs-lisp :tangle yes
(setq require-final-newline 'ask)
#+end_src

This little hack prevents ~persp-mode~ to bother me when saving its =autosave= file. We advice ~basic-save-buffer~ so files in ~persp-save-dir~ insert a breakline if missing one.

#+begin_src emacs-lisp :tangle yes
(after! persp-mode
  (defadvice! dan/persp-autosave--add-breakline (&rest _)
    "Automatically add breakline for certain buffers before saving to file."
    :before #'basic-save-buffer
    (when (and
           (/= (point-max) (point-min))
           (/= (char-after (1- (point-max))) ?\n)
           (string-equal (file-name-directory
                          (or (buffer-file-name (current-buffer)) ""))
                         persp-save-dir))
      (goto-char (point-max))
      (insert ?\n))))
#+end_src

*** Nix

Use ~alejandra~ as the default formatter.

#+begin_src emacs-lisp :tangle yes
(after! nix-mode
  (set-formatter! 'alejandra "alejandra --quiet" :modes '(nix-mode))
  (map! :localleader
        :map nix-mode-map
        :desc "nix-format-buffer" "p" #'+format/buffer))
#+end_src

*** nodejs

~nodejs-repl~ is a super useful package. However, it's missing a comfortable way to interact with promises. We can change that with an experimental =nodejs=.

#+begin_src emacs-lisp :tangle yes
(after! nodejs-repl
  (setq nodejs-repl-arguments '("--experimental-repl-await")))
#+end_src

*** Org

One of the killer features of Emacs.

#+begin_src emacs-lisp :tangle yes
(use-package! org
    :defer t
#+end_src

If you use ~org~ and don't want your org files in the default location below,
change ~org-directory~. It must be set before org loads!

#+begin_src emacs-lisp :tangle yes
    :custom
    (org-directory "~/Cloud/org/")
#+end_src

Set ~org-attach-id-dir~ back to default value.

#+begin_src emacs-lisp :tangle yes
    (org-attach-id-dir  "data")
#+end_src

Any file in the ~agenda~ directory is part of the agenda view.

#+begin_src emacs-lisp :tangle yes
    (org-agenda-files (list (expand-file-name "agenda/" org-directory)))
#+end_src

Make emphasis markers auto-hide.

#+begin_src emacs-lisp :tangle yes
    (org-hide-emphasis-markers t)
#+end_src

Modules for keeping track of habits and completing checklists.

#+begin_src emacs-lisp :tangle yes
    (org-module  '(org-habit org-checklist))
#+end_src

Don't show TODOs which are scheduled in the future.

#+begin_src emacs-lisp :tangle yes
    (org-agenda-todo-ignore-scheduled 'future)
#+end_src

A project with no NEXT subheads is stuck.

#+begin_src emacs-lisp :tangle yes
    (org-stuck-projects '("TODO=\"PROJ\"" ("NEXT") nil ""))
#+end_src

Default priority is lowest priority

#+begin_src emacs-lisp :tangle yes
    (org-priority-default org-priority-lowest)
#+end_src

Add custom functions to some org hooks. First, a function that runs when
subheading change KEYWORD state.

#+begin_src emacs-lisp :tangle yes
    :config
    (add-hook! 'org-after-todo-statistics-hook #'dan/org-after-todo-statistics-preserve-todo-state)
#+end_src

In org buffers, remove the line number fringe.

#+begin_src emacs-lisp :tangle yes
    (add-hook! org-mode (setq-local display-line-numbers nil))
#+end_src

Switch header 'TODO' state to 'DONE' when all checkboxes are ticked, to 'TODO'
otherwise

#+begin_src emacs-lisp :tangle yes
    (add-hook! 'org-checkbox-statistics-hook  #'dan/org-checkbox-statistics-change-to-done-when-all-ticked))
#+end_src

Skip sub-tasks whose parents are scheduled in the future. The function ~org-agenda-skip-function~ can be used in individual commands instead.

#+begin_src emacs-lisp :tangle yes
(after! org
  (setq org-agenda-skip-function-global
         (defun dan/org-agenda-skip-if-inherited-timestamp ()
           "Skip item with an inherited timestamp according to the org-agenda settings..
Uses built-in `org-agenda-check-for-timestamp-as-reason-to-ignore-todo-item'."
           (let ((subtree-end (save-excursion (org-end-of-subtree t)))
                 (ignore-item-p (org-agenda-check-for-timestamp-as-reason-to-ignore-todo-item)))
             (while (and (org-up-heading-safe)
                         (null ignore-item-p))
               (setq ignore-item-p (org-agenda-check-for-timestamp-as-reason-to-ignore-todo-item)))
             (when ignore-item-p
               subtree-end)))))
#+end_src

Use the TODO keywords that suit my workflow.

- TODO :: Self-explanatory
- NEXT :: Within a PROJ, what needs to be done next.
- PROJ :: Indicated a PROJECT, personal or work related.
- WAIT :: Tasks that are in WAIT of another.
- EVENT :: Indicates an event.
- IDEA :: Indicates a potential idea, for a task or project, in the future. A backlog of sorts.
- DONE :: Self-explanatory
- CANCELLED :: Self-explanatory. It's better if they have a note explaining why.

Also, add them faces so they stick out more:

#+begin_src emacs-lisp :tangle yes
(after! org
  (custom-declare-face '+org-todo-wait  '((t (:inherit (bold mode-line-emphasis org-todo)))) "")
  (setq org-todo-keywords '((sequence "TODO(t)" "NEXT(n)" "PROJ(p)" "WAIT(w)" "IDEA(i)" "EVENT(e)" "|"
                                      "DONE(d)" "CANCELLED(c)"))
        org-todo-keyword-faces '(("NEXT"      . +org-todo-active)
                                 ("WAIT"      . +org-todo-wait)
                                 ("EVENT"     . +org-todo-onhold)
                                 ("PROJ"      . +org-todo-project)
                                 ("CANCELLED" . +org-todo-cancel))))
#+end_src

~org-capture-templates~ are task templates that help automate the process of automating tasks. The defaults in =doom= are a bit over-kill for me and make assumptions that are not fit for my workflow flow.

The key files of the capture template are:

- ~+org-capture-projects-file~ :: Project related todos.
- ~+org-capture-todo-file~ :: Unplanned or emergent todos, tend to be resolved quickly.
- ~+org-capture-journal-file~ :: Scheduled todos or events.
- ~+org-capture-notes-file~ :: Ideas file.

#+begin_src emacs-lisp :tangle yes
(after! org
  (setq +org-capture-projects-file (expand-file-name "projects.org" (car org-agenda-files))
        +org-capture-todo-file (expand-file-name "diary.org" (car org-agenda-files))
        +org-capture-journal-file (expand-file-name "schedule.org" (car org-agenda-files))
        +org-capture-notes-file (expand-file-name "ideas.org" (car org-agenda-files))))
#+end_src

And the templates that use those files:

#+begin_src emacs-lisp :tangle yes
(after! org
  (setq org-capture-templates '(("t" "Quick todo" entry
                                 (file+headline +org-capture-todo-file "Quick errands")
                                 "* TODO %?\n%i\n" :prepend t)
                                ("e" "Event" entry
                                 (file+olp +org-capture-journal-file "Events")
                                 "* EVENT %?\n%i\n" :prepend nil)
                                ("i" "Random idea" entry
                                 (file+olp +org-capture-notes-file "Inbox")
                                 "* IDEA %?\n%i\n" :prepend t)
                                ("p" "Centralized templats for projects")
                                ("pt" "Project todo" entry
                                 #'+org-capture-central-project-todo-file
                                 "* TODO %?\n %i\n %a" :heading "Tasks" :prepend t)
                                ("pe""Project event" entry
                                 #'+org-capture-central-project-todo-file
                                 "* EVENT %?\n %i\n" :heading "Events" :prepend nil)
                                ("pi" "Project idea" entry
                                 #'+org-capture-central-project-todo-file
                                 "* IDEA %?\n %i\n %a" :heading "Ideas" :prepend t))))
#+end_src

Easier to find ~org-attach~ links.

#+begin_src emacs-lisp :tangle yes
(after! org
  (setq org-id-method 'ts
        org-attach-id-to-path-function-list '(org-attach-id-ts-folder-format
                                              org-attach-id-uuid-folder-format)))
#+end_src

Now we specify the ~org-refile-targets~. Any open org file and the files that are part of the agenda.

#+begin_src emacs-lisp :tangle yes
(after! org
  (setq org-refile-targets '((nil              :maxlevel . 9)
                             (org-agenda-files :maxlevel . 9))))
#+end_src

The default agenda view shows yesterdays task, todays and tomorrows.

#+begin_src emacs-lisp :tangle yes
(after! org-agenda
  (setq org-agenda-start-on-weekday nil
        org-agenda-start-day        "-1d"
        org-agenda-span             3))
#+end_src

Keybinding for the default agenda.

#+begin_src emacs-lisp :tangle yes
(map! :leader
      :desc "3 Day Org Agenda" "o a d" #'org-agenda-list)
#+end_src

#+begin_src emacs-lisp :tangle yes
(after! (org org-agenda)
  (map! :map org-agenda-mode-map
        :localleader
        "f" #'org-agenda-follow-mode))
#+end_src

**** Auto-loads

Lexical Binding.

#+begin_src emacs-lisp :tangle autoload/org.el :mkdirp yes
;;; $DOOMDIR/autoload/org.el -*- lexical-binding: t; -*-
#+end_src

Define the custom function, switch entry to 'DONE' when all sub-entries are
'DONE', else keep entry original todo state.

#+begin_src emacs-lisp :tangle autoload/org.el :mkdirp yes
;;;###autoload
(defun dan/org-after-todo-statistics-preserve-todo-state (n-done n-not-done)
  "Change `TODO' state to `DONE' if all subheadings are also `DONE', otherwise
conserve `TODO' state.

N-DONE are the number of subheadings that are done and N-NOT-DONE the number of
headings that are not done. This function is meant to be run as part of
`org-after-todo-statistics-hook'."
  (let (org-log-done org-log-states)
    (org-todo (if (= n-not-done 0)
                  "DONE"
                (concat (org-get-todo-state))))))
#+end_src

Custom function that switches heading from 'TODO' to 'DONE' when all checkboxes are ticked.

#+begin_src emacs-lisp :tangle autoload/org.el :mkdirp yes
;;;###autoload
(defun dan/org-checkbox-statistics-change-to-done-when-all-ticked ()
  "Change `TODO' state to `DONE' if all checkboxes of the heading are ticked.

This function is meant to be run as as part of `org-checkbox-statistics-hook'."
  (let ((todo-state (condition-case _
                        (org-get-todo-state)
                      (user-error nil)))
        beg
        end)
    (when todo-state
      (save-excursion
        (org-back-to-heading t)
        (setq beg (point))
        (end-of-line)
        (setq end (point))
        (goto-char beg)
        (if (re-search-forward "\\[\\([0-9]*%\\)\\]\\|\\[\\([0-9]*\\)/\\([0-9]*\\)\\]"
                               end t)
            (if (match-end 1)
                (when (equal (match-string 1) "100%")
                    (unless (string-equal todo-state "DONE")
                      (org-todo 'done)))
              (when (and (> (match-end 2) (match-beginning 2))
                         (equal (match-string 2) (match-string 3)))
                  (unless (string-equal todo-state "DONE")
                    (org-todo 'done)))))))))
#+end_src

*** org-appear

Add integration with ~evil-mode~, to auto hide/show entities.

#+begin_src emacs-lisp :tangle yes
(after! org
  (add-hook! org-mode #'org-appear-mode))
#+end_src

*** org-edna

=org-edna= offers more control over how and when tasks change state and manages
dependencies between tasks through extra heading properties.

#+begin_src emacs-lisp :tangle packages.el
(package! org-edna)
#+end_src

Load and activate ~org-edna~ together with ~org~.

#+begin_src emacs-lisp :tangle yes
(use-package! org-edna
  :hook (org-load . org-edna-mode)
#+end_src

Make =org-edna= to trigger in any state change except done.

#+begin_src emacs-lisp :tangle yes
  :custom
  (org-edna-from-todo-states 'not-done))
#+end_src

*** org-sticky-header

Like =topsy=, for org mode.

#+begin_src emacs-lisp :tangle packages.el
(package! org-sticky-header)
#+end_src

Lazy load only in ~org-mode~ buffers.

#+begin_src emacs-lisp :tangle yes
(use-package! org-sticky-header
  :hook (org-mode . org-sticky-header-mode))
#+end_src

*** org-super-agenda

#+begin_quote
This package lets you â€œsuperchargeâ€ your Org daily/weekly agenda. The idea is to group items into sections, rather than having them all in one big list.
#+end_quote

#+begin_src emacs-lisp :tangle packages.el
(package! org-super-agenda)
#+end_src

#+begin_quote
So this package filters the results from org-agenda-finalize-entries, which runs just before items are inserted into agenda views. It runs them through a set of filters that separate them into groups. Then the groups are inserted into the agenda buffer, and any remaining items are inserted at the end. Empty groups are not displayed.

The end result is your standard daily/weekly agenda, but arranged into groups defined by you. You might put items with certain tags in one group, habits in another group, items with certain todo keywords in another, and items with certain priorities in another. The possibilities are only limited by the grouping functions.
u
The primary use of this package is for the daily/weekly agenda, made by the org-agenda-list command, but it also works for other agenda views, like org-tags-view, org-todo-list, org-search-view, etc.
#+end_quote

#+begin_src emacs-lisp :tangle yes
(use-package! org-super-agenda
  :after org
  :config
  (org-super-agenda-mode)
#+end_src

With the package installed, we are ready to define ~org-agenda-custom-commands~ as well as the ~org-super-agenda-groups~. For extra visibility, we tweak the agenda sorting strategy to make priority hight tasks appear early.

#+begin_src emacs-lisp :tangle yes
  :custom
  (org-agenda-sorting-strategy '((agenda priority-down habit-down time-up category-keep)
                                 (todo priority-down category-keep)
                                 (tags priority-down category-keep)
                                 (search category-keep)))
  (org-super-agenda-groups      '((:name "Next Items"
                                   :and (:todo "NEXT" :not (:tag ("consume"))))
                                  (:name "Important"
                                   :and (:priority "A" :not (:todo "WAIT")))
                                  (:name "In Hold"
                                   :and (:not (:tag ("consume")) :todo "WAIT"))
                                  (:name "Incoming Events"
                                   :and (:todo "EVENT"))
                                  (:name "Candidates"
                                   :and (:not (:todo ("EVENT" "WAIT"))
                                         :priority "B"))
                                  (:name "Backlog"
                                   :and (:todo "TODO" :not (:tag ("consume") :priority>= "B")))
                                  (:name "Ideas"
                                   :and (:not (:tag ("consume")) :todo "IDEA"))
                                  (:name "Active projects"
                                   :todo "PROJ")
                                  (:name "Entertainment"
                                   :tag  ("entertainment"))
                                  (:name "Wishlist"
                                   :tag  ("wishlist")))))
#+end_src

There are a few clashes between ~evil-org-agenda-mode-map~ and ~org-super-agenda-header-map~. To remove them, we simply override the latter keymap, after loading both ~evil-org-agenda~ and ~org-super-agenda~.

#+begin_src emacs-lisp :tangle yes
(after! (evil-org-agenda org-super-agenda)
  (setq org-super-agenda-header-map (copy-keymap evil-org-agenda-mode-map)))
#+end_src

To prevent unnecessary scrolling when calling the agenda buffer, we automate the cursor position on agenda ~todo~ views.

#+begin_src emacs-lisp :tangle yes
(after! (evil-org-agenda org-super-agenda)
 (add-hook! 'org-agenda-finalize-hook
            :append (when (and (org-agenda-check-type nil 'todo)
                               ;; Don't do any of this if the buffer is narrowed.
                               (not (buffer-narrowed-p)))
                     (goto-char (point-min))
                     (re-search-forward "^$")
                     (forward-line)
                     (evil-scroll-line-to-center (count-lines (point-min)
                                                              (point)))
                     (org-agenda-next-item 1))))
#+end_src

Prevent ~org-capture~ buffers from loosing their target when restarting.

#+begin_src emacs-lisp :tangle yes
(after! org
  (defadvice! dan/+org--restart-mode-h-careful-restart (fn &rest args)
    :around #'+org--restart-mode-h
    (let ((old-org-capture-current-plist (and (bound-and-true-p org-capture-mode)
                                              (bound-and-true-p org-capture-current-plist))))
      (apply fn args)
      (when old-org-capture-current-plist
        (setq-local org-capture-current-plist old-org-capture-current-plist)
        (org-capture-mode +1)))))
#+end_src

Prevent false error messages with ~org-element--cache-sync~.

#+begin_src emacs-lisp :tangle yes
(after! org
  (add-hook! 'org-capture-after-finalize-hook (org-element-cache-reset t)))
#+end_src

#+begin_src emacs-lisp :tangle yes
#+end_src

*** PDF Tools

We reduce the default zoom factor to have more leeway between zoom levels.

#+begin_src emacs-lisp :tangle yes
(after! pdf-tools
  (setq pdf-view-resize-factor 1.05))
#+end_src

We also auto install ~epdinfo~.

#+begin_src emacs-lisp :tangle yes
(after! pdf-tools
   (pdf-loader-install t))
#+end_src

*** Personal information

Some functionality uses this to identify you, e.g. GPG configuration, email
clients, file templates and snippets.

#+begin_src emacs-lisp :tangle yes
(setq user-full-name    "Daniel Levy Moreno"
      user-mail-address "daniellevymoreno@gmail.com")
#+end_src

*** Proced

A builtin hidden gem, which has substituted =htop= for me.

#+begin_quote
Mode for displaying system processes and sending signals to them.
#+end_quote

#+begin_src emacs-lisp :tangle yes
(use-package! proced
  :defer t
#+end_src

By default, =proced= doesn't auto update the process list, which is a bummer. Luckily, we can change that.

#+begin_src emacs-lisp :tangle yes
  :custom
  (proced-auto-update-flag t)
  (proced-auto-update-interval 1))
#+end_src

*** Projectile

Let's make projectile's life easier by giving it some paths where I normally
store projects.

#+begin_src emacs-lisp :tangle yes
(setq projectile-project-search-path '("~/Projects/" "~/.config/"))
#+end_src

*** QR encode

#+begin_quote
QR Code encoder written in pure Emacs Lisp.
#+end_quote

#+begin_src emacs-lisp :tangle packages.el
(package! qrencode)
#+end_src

#+begin_quote
This package provides two user facing interactive functions, that will encode text into a QR Code and show it in a separate buffer.

~qrencode-region~
    Shows the current selection as a QR Code.

~qrencode-url-at-point~
    Encode URL at point as QR Code.
#+end_quote

#+begin_src emacs-lisp :tangle yes
(use-package! qrencode
    :defer t)
#+end_src

*** Rainbow Delimiters

Matching pairs draw with the same face color, making them easily identifiable.

#+begin_src emacs-lisp :tangle yes
(add-hook! prog-mode #'rainbow-delimiters-mode-enable)
#+end_src

*** run-command

#+begin_quote
run-command you write a short recipe and obtain a command that is easy to bring up, invoke, and keep track of, without leaving Emacs.
#+end_quote

#+begin_src emacs-lisp :tangle packages.el
(package! run-command)
#+end_src

We advice ~run-command--run-compile~ to use =detached=.

#+begin_src emacs-lisp :tangle yes
(use-package! run-command
  :defer t
  :config
  ;; NOTE: Forgotten builtin dependency
  (unless (featurep 'map)
    (require 'map))
  (defadvice! dan/run-command--run-detached-shell-command (command-line buffer-base-name)
    "Override `run-command--run-compile' to use `detached-compile'."
    :override #'run-command--run-compile
    (let ((compilation-buffer-name-function
           (lambda (_name-of-mode) buffer-base-name)))
      (detached-compile command-line t))))
#+end_src

Make sure ~run-command~ uses =vertico=.

#+begin_src emacs-lisp :tangle yes
(after! run-command
  (setq run-command-completion-method 'completing-read))
#+end_src

An easy =mnemonic= keybinding.

#+begin_src elisp :tangle yes
(map! :leader
      "o c" #'run-command)
#+end_src

=NixOS= recipes.

#+begin_src emacs-lisp :tangle yes
(after! run-command
  (defun dan/run-command--nix ()
    (if IS-LINUX
        (list
         (list :command-line "rm -f ~/.config/mimeapps.list && sudo nixos-rebuild switch --flake '/etc/nixos#nyx15v2'"
               :command-name "Rebuild NixOS"
               :display "Create a new NixOS generation and switch to it")
         (list :command-line "nix flake update /etc/nixos"
               :command-name "Update NixOS"
               :display "Update the NixOS flake inputs")
         (list :command-line "sudo nix-collect-garbage -d"
               :command-name "GC NixOS"
               :display "Delete unused derivations and previous generations"))
      (list
       (list :command-line "darwin-rebuild switch --flake '/Users/dlevy/.config/nixos#autoMac'"
             :command-name "Rebuild darwin"
             :display "Create a new darwin generation and switch to it")
       (list :command-line "darwin-rebuild check --flake '/Users/dlevy/.config/nixos#autoMac'"
             :command-name "Check darwin"
             :display "Check if new darwin generation can is buildable")
       (list :command-line "nix flake update /Users/dlevy/.config/nixos"
             :command-name "Update darwin"
             :display "Update the darwin flake inputs")
       (list :command-line "nix-collect-garbage -d"
             :command-name "GC darwin"
             :display "Delete unused derivations and previous generations"))))
  (add-to-list 'run-command-recipes #'dan/run-command--nix t))
#+end_src

*** Rust

Use =rust-analyzer= by default, since it has more features.

#+begin_src emacs-lisp :tangle yes
(use-package! rustic
  :defer t
  :custom
  (rustic-lsp-server 'rust-analyzer)
#+end_src

When using the rustic popup, be in Emacs state.

#+begin_src emacs-lisp :tangle yes
  :config
  (when (featurep 'evil)
    (add-hook! 'rustic-popup-mode-hook #'evil-emacs-state)))
#+end_src

*** Snow

A nice, comfy, useless package.

#+begin_src emacs-lisp :tangle packages.el
(package! snow)
#+end_src

We define an auto-load function as an entry point to the winter season.

#+begin_src emacs-lisp :tangle yes
(use-package! snow
  :commands snow)
#+end_src

*** Solidity

~solidity-mode~ is a bit barebores. We can help it along adding ~company-yasnippet~ and ~company-dabbrev-code~ for better autocompletion.

#+begin_src emacs-lisp :tangle yes
(after! (solidity-mode company-solidity company-yasnippet)
  (set-company-backend! 'solidity-mode
    'company-solidity 'company-yasnippet 'company-dabbrev-code))
#+end_src

*** Splash Screen

Default doom dashboard is pretty and welcoming, let's just give it a small personal touch.

#+begin_src emacs-lisp :tangle yes
(setq fancy-splash-image (expand-file-name "img/qs.png" doom-private-dir))
#+end_src

#+HTML: <p align="center"><img src="https://raw.githubusercontent.com/danilevy1212/doom/master/img/qs.png"/></p>

But what if I am in the terminal? No worries:

#+begin_src emacs-lisp :tangle yes
(defun dan/my-weebery-is-always-greater ()
  (mapc (lambda (line)
          (insert (propertize (+doom-dashboard--center +doom-dashboard--width line)
                              'face 'doom-dashboard-banner) " ")
          (insert "\n"))
        '("â¢¸â£¿â£¿â£¿â£¿â ƒâ „â¢€â£´â¡¾â ƒâ „â „â „â „â „â ˆâ ºâ Ÿâ ›â ›â ›â ›â »â¢¿â£¿â£¿â£¿â£¿â£¶â£¤â¡€â „"
          "â¢¸â£¿â£¿â£¿â¡Ÿâ¢€â£´â£¿â¡¿â â „â „â „â „â „â „â „â „â „â „â „â „â „â „â£¸â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£·"
          "â¢¸â£¿â£¿â Ÿâ£´â£¿â¡¿â¡Ÿâ¡¼â¢¹â£·â¢²â¡¶â£–â£¾â£¶â¢„â „â „â „â „â „â¢€â£¼â£¿â¢¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿"
          "â¢¸â£¿â¢«â£¾â£¿â¡Ÿâ£¾â¡¸â¢ â¡¿â¢³â¡¿â â£¼â£¿â¢â£¿â£·â¢„â¡€â „â¢ â£¾â¢»â£¿â£¸â£¿â£¿â£¿â£¿â£¿â£¿â£¿"
          "â¡¿â£¡â£¿â£¿â¡Ÿâ¡¼â¡â â£°â ‚â¡¾â ‰â¢¨â£¿â ƒâ£¿â¡¿â â£¾â£Ÿâ¢¤â£¿â¢‡â£¿â¢‡â£¿â£¿â¢¿â£¿â£¿â£¿â£¿â£¿"
          "â£±â£¿â£¿â¡Ÿâ¡â£°â£§â¡·â£¿â£´â£§â£¤â£¼â£¯â¢¸â¡¿â â£°â Ÿâ¢€â£¼â â£²â â¢¸â£¿â¡Ÿâ£¿â£¿â£¿â£¿â£¿â£¿"
          "â£¿â£¿â¡Ÿâ â „â Ÿâ£â „â¢¡â£¿â£¿â£¿â£¿â£¿â£¿â£¦â£¼â¢Ÿâ¢€â¡¼â ƒâ¡¹â ƒâ¡€â¢¸â¡¿â¢¸â£¿â£¿â£¿â£¿â£¿â¡Ÿ"
          "â£¿â£¿â ƒâ „â¢€â£¾â ‹â “â¢°â£¿â£¿â£¿â£¿â£¿â£¿â ¿â£¿â£¿â£¾â£…â¢”â£•â¡‡â¡‡â¡¼â¢â£¿â£¿â£¿â£¿â£¿â£¿â¢£"
          "â£¿â¡Ÿâ „â „â£¾â£‡â ·â£¢â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£­â£€â¡ˆâ ™â¢¿â£¿â£¿â¡‡â¡§â¢â£¾â£¿â£¿â£¿â£¿â£¿â¢â£¾"
          "â£¿â¡‡â „â£¼â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â Ÿâ¢»â ‡â „â „â¢¿â£¿â¡‡â¢¡â£¾â£¿â£¿â£¿â£¿â£¿â£â£¼â£¿"
          "â£¿â£·â¢°â£¿â£¿â£¾â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¢°â£§â£€â¡„â¢€â ˜â¡¿â£°â£¿â£¿â£¿â£¿â£¿â£¿â Ÿâ£¼â£¿â£¿"
          "â¢¹â£¿â¢¸â£¿â£¿â Ÿâ »â¢¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¶â£­â£‰â£¤â£¿â¢ˆâ£¼â£¿â£¿â£¿â£¿â£¿â£¿â â£¾â£¹â£¿â£¿"
          "â¢¸â ‡â¡œâ£¿â¡Ÿâ „â „â „â ˆâ ™â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â Ÿâ£±â£»â£¿â£¿â£¿â£¿â£¿â Ÿâ â¢³â ƒâ£¿â£¿â£¿"
          "â „â£°â¡—â ¹â£¿â£„â „â „â „â¢€â£¿â£¿â£¿â£¿â£¿â£¿â Ÿâ£…â£¥â£¿â£¿â£¿â£¿â ¿â ‹â „â „â£¾â¡Œâ¢ â£¿â¡¿â ƒ"
          "â œâ ‹â¢ â£·â¢»â£¿â£¿â£¶â£¾â£¿â£¿â£¿â£¿â ¿â£›â£¥â£¾â£¿â ¿â Ÿâ ›â ‰â „â „          ")))

(when (not (display-graphic-p))
  (setq +doom-dashboard-ascii-banner-fn #'dan/my-weebery-is-always-greater))
#+end_src

*** telega

=telega= is full featured unofficial client for Telegram platform for GNU Emacs.

#+begin_src emacs-lisp :tangle packages.el
(package! telega
  :recipe (:files (:defaults
                   "contrib/*.el"
                   "etc"
                   "server"
                   "Makefile")))
#+end_src

Minimal configuration to be able to build the server and load the cache.

#+begin_src emacs-lisp :tangle yes
(use-package! telega
  :defer t
  :custom
  (telega-directory (expand-file-name "telega" doom-cache-dir))
  (telega-video-player-command '(concat "mpv"
                                        (when telega-ffplay-media-timestamp
                                          (format " --start=%f" telega-ffplay-media-timestamp))))
  (telega-completing-read-function completing-read-function)
  (telega-server-libs-prefix (getenv "TDLIB_PREFIX"))
  (telega-use-docker t))
#+end_src

Quick keybinding to open =telega=.

#+begin_src emacs-lisp :tangle yes
(map! :leader
    :desc "telegram" :mv "o m" #'telega)
#+end_src

~evil-snipe~ shadows the =search= default bindings of =telega= in ~evil-collection~, so we disable it for ~telega-root-mode~.

#+begin_src emacs-lisp :tangle yes
(after! evil-snipe
  (add-to-list 'evil-snipe-disabled-modes 'telega-root-mode))
#+end_src

We set up auto-completion for chats.

#+begin_src emacs-lisp :tangle yes
(after! telega
  (set-company-backend! 'telega-chat-mode
    '(:separate
      telega-company-telegram-emoji
      telega-company-username
      telega-company-botcmd
      telega-company-hashtag
      company-ispell
      company-dabbrev)))
#+end_src

Finally, we add some extra goodies, some in =core= and others in =contrib=. These include visual customization like =shortening url's= or =code blocks syntax highlighting= to more complicated functionality like =system notifications= brought to you via ~alert.el~.

#+begin_src emacs-lisp :tangle yes
(add-hook! telega-load
           ;; core
           #'telega-mode-line-mode
           #'global-telega-squash-message-mode
           #'telega-notifications-mode

           ;; contrib
           #'global-telega-url-shorten-mode
           #'global-telega-mnz-mode
           #'telega-alert-mode
           #'telega-transient-mode
           #'telega-status-history-mode)
#+end_src

Highlight the current line in =telega= buffer.

#+begin_src emacs-lisp :tangle yes
(add-hook! '(telega-root-mode-hook telega-chat-mode-hook)
           #'hl-line-mode)
#+end_src

Sometimes ~telega~ emacs when trying to quit it. Forcing to quit ~telega~ when quitting =emacs= prevents this situation.

#+begin_src emacs-lisp :tangle yes
(add-hook! kill-emacs
  (when (and (boundp 'telega-root-buffer-name)
             (get-buffer telega-root-buffer-name))
    (telega-kill t)))
#+end_src

Center the text of chat buffers for more comfy reading.

#+begin_src emacs-lisp :tangle yes
(add-hook! telega-chat-mode #'+zen/toggle)
#+end_src

*** Term

Make =urls= clickable in ~term~ modes.

#+begin_src emacs-lisp :tangle yes
(add-hook! term-mode #'goto-address-mode)
#+end_src

*** topspace

#+begin_quote
Scroll down and recenter top lines in Emacs.

- Easier on the eyes: Recenter or scroll down top text to a more comfortable eye level for reading, especially when in full-screen or on a large monitor.

- Easy to use: No new keybindings are required, keep using all your previous scrolling & recentering commands, except now you can also scroll above the top lines. It also integrates seamlessly with centered-cursor-mode to keep the cursor centered all the way to the top line.
#+end_quote

#+begin_src emacs-lisp :tangle packages.el
(package! topspace)
#+end_src

A package I didn't know I needed.

#+begin_src emacs-lisp :tangle yes
(use-package! topspace
  :custom
  (topspace-active             #'dan/topspace--active-p)
  (topspace-autocenter-buffers #'dan/topspace--active-p)
  (indicate-empty-lines        t)
  :hook
  (doom-first-buffer . global-topspace-mode))
#+end_src

We create a =blacklist= of sorts to deactivate ~topspace-mode~ in special modes.

#+begin_src emacs-lisp :tangle yes
(after! topspace
  (defun dan/topspace--active-p ()
    (not (or (minibufferp)
             (derived-mode-p 'vterm-mode
                             'comint-mode
                             'org-agenda-mode
                             '+doom-dashboard-mode
                             'magit-mode
                             'telega-root-mode
                             'telega-chat-mode
                             'image-mode
                             'Custom-mode
                             'compilation-mode
                             'elfeed-search-mode
                             'elfeed-show-mode
                             'cfw:calendar-mode
                             'special-mode)))))
#+end_src

*** Topsy

This library shows a sticky header at the top of the window. The header shows which definition the top line of the window is within.

#+begin_src emacs-lisp :tangle packages.el
(package! topsy)
#+end_src

We activate ~topsy-mode~ only in programming contexts.

#+begin_src emacs-lisp :tangle yes
(use-package! topsy
  :defer t
  :init
  (add-hook! prog-mode
    (unless (memq major-mode '(+doom-dashboard-mode org-mode))
      (topsy-mode +1)))
#+end_src

To make the ~header-line~ a little more noticeable while consistent with the buffer style, we change it's font and inherit from the ~default~ style.

#+begin_src emacs-lisp :tangle yes
  :config
  (custom-set-faces!
    '(header-line :family "Victor Mono"
                  :inherit default)))
#+end_src

*** uniquify

Uniquify makes buffers with the same name easier to distinguish. The ~'forward~ configuration shows the file path of the buffer.

#+begin_src emacs-lisp :tangle yes
(setq uniquify-buffer-name-style 'forward)
#+end_src

*** use-package

We want packages to be lazy by default. In other words, load only on demand.

#+begin_src emacs-lisp :tangle yes
(setq use-package-always-defer t)
#+end_src

Make it easy to find ~use-package~ definitions in ~emacs-lisp~ buffers.

#+begin_src emacs-lisp :tangle yes
(setq use-package-enable-imenu-support t)
#+end_src

*** vc-gutter

Let's add minor customization to the =vc-gutter= module:

First, diff the file while the buffer is changing, not just when it's saved.

#+begin_src emacs-lisp :tangle yes
(setq +vc-gutter-diff-unsaved-buffer t)
#+end_src

Lastly, let's activate =git-gutter= for remote files as well.

#+begin_src emacs-lisp :tangle yes
(setq +vc-gutter-in-remote-files t)
#+end_src

*** Vterm

Make =urls= clickable in ~vterm~ modes.

#+begin_src emacs-lisp :tangle yes
(add-hook! vterm-mode #'goto-address-mode)
#+end_src

Maximum scrollback to the max!

#+begin_src emacs-lisp :tangle yes
(after! vterm
  (setq vterm-max-scrollback 100000))
#+end_src

Make ~vterm~ as snappy as it can be.

#+begin_src emacs-lisp :tangle yes
(after! vterm
  (setq vterm-timer-delay nil))
#+end_src

*** Vundo

A visual representation of =emacs= built-in =undo tree=.

#+begin_src emacs-lisp :tangle packages.el
(package! vundo)
#+end_src

For node navigation:

| Key | Description                                           |
|-----+-------------------------------------------------------|
| =l=   | to go forward                                         |
| =h=   | to go backward                                        |
| =j=   | to go to the node below when you at a branching point |
| =k=   | to go to the node above                               |
| =H=   | to go back to the last branching point                |
| =L=   | to go forward to the end/tip of the branch            |
| =q=   | to quit, you can also type C-g                        |

#+begin_src emacs-lisp :tangle yes
(use-package! vundo
  :custom
  (vundo-glyph-alist     vundo-unicode-symbols)
  (vundo-compact-display t)
  :config
  (map! :map vundo-mode-map
        [remap doom/escape]        #'vundo-quit)
  :defer t)
#+end_src

Set an entry point.

#+begin_src emacs-lisp :tangle yes
(map! :leader
      :desc "Visual Undo Tree" "b U" #'vundo)
#+end_src

*** Which Key

Doom Emacs default configuration is too slow, let's speed it up.

#+begin_src emacs-lisp :tangle yes
(after! which-key
  (setq which-key-idle-delay           0.1
        which-key-idle-secondary-delay 0.2))
#+end_src

*** Word wrap

I work with lots of files that have long lines, which can be hard to read
sometimes. ~+word-wrap-mode~ helps to make these files more readable without
changing the buffer contents.

#+begin_src emacs-lisp :tangle yes
(add-hook! 'doom-first-buffer-hook #'+global-word-wrap-mode)
#+end_src

*** World Clock

I have family all over the place, it's hard to keep up with the time difference. Luckily, =emacs= can help with ~world-clock~ mode.

#+begin_src emacs-lisp :tangle yes
(after! time
  (setq world-clock-list '(("America/New_York"    "North Wales")
                           ("America/Los_Angeles" "Napa")
                           ("America/Sao_Paulo"   "Brasilia")
                           ("Europe/Madrid"       "Madrid")
                           ("Asia/Kolkata"        "India")
                           ("Asia/Singapore"      "Singapore")
                           ("Asia/Tokyo"          "Tokyo"))))
#+end_src

Make the =wclock= buffer into a popup.

#+begin_src emacs-lisp :tangle yes
(set-popup-rule! "^\\*wclock" :quit 'current :side 'top)
#+end_src

Make it quit-able with =q=.

#+begin_src emacs-lisp :tangle yes
(after! time
  (map! :map 'world-clock-mode-map
        :nm "q" #'quit-window))
#+end_src

Make it play nice with ~evil-mode~.

#+begin_src emacs-lisp :tangle yes
(add-hook! world-clock-mode #'evil-normalize-keymaps)
#+end_src

Give it an easy entry keybinding ~SPC o w~.

#+begin_src emacs-lisp :tangle yes
(map! :leader
      :desc "World Clock" :nm "o w" #'world-clock)
#+end_src

*** Writeroom

Keep header lines for ~+zen-mode~, so ~org-sticky-header-mode~ works as intended.

#+begin_src emacs-lisp :tangle yes
(add-hook! org-mode
  (setq-local writeroom-header-line t))
#+end_src

Make ~zen-mode~ togglable in a per file basis, just like in this ~config.org~!

#+begin_src emacs-lisp :tangle yes
(add-to-list 'safe-local-eval-forms
             '(when (and (fboundp #'+zen/toggle)
                         (not noninteractive))
                (+zen/toggle)))
#+end_src

*** Yasnippet

YASnippet is a template system for Emacs. It allows you to type an abbreviation and automatically expand it into function templates.

**** org-mode

For æ—¥æœ¬èªž grammar snippets.

#+begin_src snippet :mkdirp yes :tangle snippets/org-mode/æ–‡æ³•
# -*- mode: snippet -*-
# name: æ–‡æ³•ã®äº‹é …
# key: bunpou
# --

`(make-string (+ 1 (org-outline-level)) ?*)` ${1:æ–‡æ³•ã®äº‹é …}

${2:èª¬æ˜Ž}

`(make-string (+ 2 (org-outline-level)) ?*)` æ–‡åž‹

${3:æ–‡åž‹}

`(make-string (+ 2 (org-outline-level)) ?*)` ç¿»è¨³

${4:ç¿»è¨³}

`(make-string (+ 2 (org-outline-level)) ?*)` ä¾‹

${5:ä¾‹}
${6:ä¾‹ã®ç¿»è¨³}

#+end_src

For starting a new project!

#+begin_src snippet :mkdirp yes :tangle snippets/org-mode/new_proj
# -*- mode: snippet -*-
# name: New project
# key: project
# --

`(make-string (+ 1 (org-outline-level)) ?*)` PROJ ${1:name} :${2:tag_name}:

${3:description}

`(make-string (+ 2 (org-outline-level)) ?*)` Ideas
`(make-string (+ 2 (org-outline-level)) ?*)` Tasks
`(make-string (+ 3 (org-outline-level)) ?*)` TODO ${4:My first task!}
`(make-string (+ 2 (org-outline-level)) ?*)` Events
#+end_src

** Private modules.

=doom= allows the user to [[https://github.com/hlissner/doom-emacs/blob/develop/docs/getting_started.org#writing-your-own-modules][to write their own modules]] in their ~$DOOMDIR~
directory, which will be auto-loaded at startup. It offers an extra features
like interaction and extension of ~bin/doom~, a fixed file structure where each
file is loaded at different points of the runtime and other niceties (more
~macros!~).

For now, I haven't had the need to use this feature but is good to be aware of it.
